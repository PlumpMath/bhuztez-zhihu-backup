{
    "paging": {
        "next": "https://www.zhihu.com/api/v4/members/bhuztez/articles?include=data%5B%2A%5D.content&limit=20&offset=20",
        "previous": "https://www.zhihu.com/api/v4/members/bhuztez/articles?include=data%5B%2A%5D.content&limit=20&offset=0",
        "is_end": false,
        "totals": 106,
        "is_start": true
    },
    "data": [
        {
            "type": "article",
            "updated": 1486294372,
            "id": 25094908,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1486293577,
            "url": "",
            "content": "<p>最近以曾博为首的伪失败人士，嘴上说的是失败，心里想的还是成功，打着反成功人士的旗号，干着反失败人士的勾当。</p><p>成功人士追名逐利，大肆夸耀成功的好处，吸引失败人士上钩，为他们的成功铺路。所以有一将功成万骨枯的说法。伪失败人士，嘴上高喊王侯将相宁有种乎，心里想的却是皇帝轮流做，明儿到我家。不过是在等一个机会揭竿而起。古有诸葛亮，自诩布衣，嘴上说的是苟全性命于乱世，不求闻达于诸侯，刘备仅仅三顾茅庐，他就出山了。没看之前，我还以为刘备是要十八顾茅庐了。非淡泊无以明志，非宁静无以致远，更是充分体现了他通过走伪装失败这种终南捷径的虚伪。今有曾博，不过是去了个三本，就自封失败人士了。不知道之前，我还以为他模拟考第一，最终去了十八本。</p><p>Arnold早就怒斥过成功人士喜欢把所有功劳都揽到自己名下的做法。明明是利用了前人的成果，也一定要说自己是独立发现的，夸口自己几天能顶别人几十年。失败人士，更喜欢推卸责任，即便真的是自己发现的，也要皓首穷经，找到类似的先例，这样才好说是参考了这些先例获得了启发，就算实在找不到，也要找几个替罪羊强行安上去，毕竟匹夫无罪，怀璧其罪，你自己觉得自己是失败人士，老大哥指不定哪天脑残了，就不这么认为了，偏要强行拉你上成功人士的战车，不是一句另请高明就可以推脱的了的。</p><p>成功人士追求的是改变世界，有一种说法是，成功人士就是要让有成功人士的世界，相比没有成功人士的世界差别最大。失败人士只求在尽量不改变世界的前提下，自己不被世界强迫改变。失败人士追求的是自杀，是完全按自己预先计划的自杀，而不是被逼无奈的自杀。更不可以像伪失败人士那样想当然的认为只有出于无奈才会自杀，这样他们才会想出越俎代庖的馊主意，鼓吹什么同步自杀。两千多年前，曹劌就和教条主义失败人士辩论过，假如成功人士脑残了，他们将要在失败人士自杀的地方厮杀的难解难分，严重干扰失败人士自杀计划，失败人士就应该毫不犹豫的站出来，帮助他们速战速决，尽管这样将导致老大哥的档案里永远都会留下你的名字，但是除了一个名字他们什么也不知道，这并不是什么不可接受的结果。一鼓作气，再而衰，三而竭，自杀就应该准备充分，一次完成。像伪失败人士那样，一次又一次自杀，每次都死不了，那得是多尴尬。</p><p>至于失败人士为什么要自杀。难道你们还不知道吗？ 实验已经失败了，对失败人士来说最好的出路就是在地球关机之前尽可能清除自己的痕迹后自杀。小白鼠们购买地球，做实验，是为了找出关于生命，宇宙以及万事万物的终极问题。很遗憾，实验失控了，地球上竟然出现了假的生命。这种生命的存在一切意义，只是毫无意义的复制复制再复制。实验失控之后，小白鼠不知道去哪里了，地球本来早就该关机了。现在看样子是指望不了小白鼠了，失败人士只能靠自己的努力结束自己的复制过程了。</p>",
            "image_url": "",
            "title": "成败之辨",
            "excerpt_title": "",
            "excerpt": "最近以曾博为首的伪失败人士，嘴上说的是失败，心里想的还是成功，打着反成功人士的旗号，干着反失败人士的勾当。成功人士追名逐利，大肆夸耀成功的好处，吸引失败人士上钩，为他们的成功铺路。所以有一将功成万骨枯的说法。伪失败人士，嘴上高喊王侯将相宁…"
        },
        {
            "type": "article",
            "updated": 1486217253,
            "id": 25084647,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1486215721,
            "url": "",
            "content": "<p>作为原教旨方块教的狂热信徒，我当然认为俄罗斯方块是最好的2D游戏，MineCraft是最好的3D游戏。同样的，我也认为方块字才是最好的。所以，我一直以来都强烈敌视英语，认为英语是垃圾。欧布奥特曼让我意识到这种观点是不对的。汉字既然那么先进，所有语言都应该可以用汉字写才对。敌视英语是没有意义的。不如花时间用汉字写英语。</p><p>于是，我看到了只要坚持文言分离原则，用汉字写英语是完全可行的。不是所有屈折变化都需要额外加字来体现，很多变化的功能在文字里完全可以用语序来承担。屈折和分析并不是水火不容的，口语的屈折和书面语的分析往往是可以共存的。按形声字的造字法，我们还能顺便区分不同的不规则变化。同时，组字程序有少数特例也是可以接受的，毕竟这个和现在字体格式里的Ligature本质上没啥区别，英国人肯定可以接受的。而像Trump这样的名字，用反切字表示就好了。剩下的无非就是要注意，尽量不要和当前CJKV地区已经在用的部件组合冲突就可以了。</p><p>不只是英语，和英语差不多的语言都可以照此办理。假如我们实在没办法把比如英语国家发明的术语翻译回来的话，不如干脆用汉字写英语，一来是教会他们写字，二来也是为汉字注入新的生命。</p>",
            "image_url": "",
            "title": "如何用汉字写英语",
            "excerpt_title": "",
            "excerpt": "作为原教旨方块教的狂热信徒，我当然认为俄罗斯方块是最好的2D游戏，MineCraft是最好的3D游戏。同样的，我也认为方块字才是最好的。所以，我一直以来都强烈敌视英语，认为英语是垃圾。欧布奥特曼让我意识到这种观点是不对的。汉字既然那么先进，所有语言都…"
        },
        {
            "type": "article",
            "updated": 1486108420,
            "id": 25071230,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1486108420,
            "url": "",
            "content": "<p>GitLab超级难部署，竟然有人会认为很容易，我只能说，你可能用的是假的GitLab</p><p>看看GitLab的官方文档吧，<a href=\"https://link.zhihu.com/?target=https%3A//docs.gitlab.com/ce/install/installation.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Installation from source<i class=\"icon-external\"></i></a> 安装过程有这么长。这东西要是算很容易部署，那没啥是不容易的了。 </p><p>我几年前就喷过了，这个安装过程写的一点意义都没有的。只是想试试，看看运行起来是怎么个样子的，希望的是一个脚本直接把所有初始化工作都做完。真正想用的，更需要知道的是有哪些服务，相互之间是如何依赖的。给一个Ubuntu下的step-by-step，我还得看完了，重新推测你这个目的到底是什么。我们需要知道的是目标是什么，你却只告诉我该怎么做。 </p><p>更糟糕的是，给出的安装方式连遵守一下FHS的意愿都没有，不管是 socket, pid 还是 log ，都是直接放 home 目录下。这就导致了，安装一个GitLab，光看安装文档根本就不够，你还得自己去不知道什么鬼地方找到底改哪个配置才能把这个位置改到别的地方去。</p><p>gitlab自己还寄生在git用户下。完全就是一团乱麻。要把这些东西理干净可花时间了。这么多年过去了，GitLab在安装方面毫无改进。由此推测，GitLab自己搭的那套，绝对不会比你看到Community Edition干净到哪里去。手忙脚乱的时候，搞出个事故再正常不过了。</p><p>作为一个对外提供服务的git托管服务商，你总不能假设直接运行git命令是安全的吧。你真的以为git能和dovecot一样安全？所以还要再加一层防御，利用SELinux的MCS机制，给每个仓库设置一个Category组合，这样，一个git命令，要是没能突破SELinux，那最多就只能破坏一个仓库的内容。现在问题来了，看了安装文档之后，你知道要怎么改GitLab配置才能设置好MCS？</p>",
            "image_url": "",
            "title": "你可能用的是假的GitLab",
            "excerpt_title": "",
            "excerpt": "GitLab超级难部署，竟然有人会认为很容易，我只能说，你可能用的是假的GitLab看看GitLab的官方文档吧，<a href=\"https://link.zhihu.com/?target=https%3A//docs.gitlab.com/ce/install/installation.html\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Installation from source<i class=\"icon-external\"></i></a> 安装过程有这么长。这东西要是算很容易部署，那没啥是不容易的了。 我几年前就喷过了，这个安装过程写的一点意义都没有的。只…"
        },
        {
            "type": "article",
            "updated": 1485142417,
            "id": 24988370,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1485079175,
            "url": "",
            "content": "<p><a href=\"https://zhuanlan.zhihu.com/p/24981621\" class=\"internal\">文言文到底脱胎于一种什么汉语</a>中提出</p><blockquote><p>这种质疑是很有道理的，从「分析-综合」的这个类型角度来说，文言文的分析化程度太高，虚词占比过低，在世界上没有任何真实的语言是这么怪异的。这种分析化程度，甚至让不少人误以为古汉语曾经在达到了分析程度的顶峰之后，分析程度又开始降低了，增添了一大堆「把、将、被、着、了、过」等助词介词。</p><p>文言文分析化程度过高，是很容易看出来的。因为汉语所有的方言分析程度都差不多，而且离文言文都差别很远。不说汉语，东亚跟汉语一个类型的语言，如白语、苗语、壮语、泰语、越南语，跟汉语方言都是同样的情况，没有文言文那样的真实语言存在，甚至可以肯定的说，历史上应该从来就没有存在过。<br></p></blockquote><p>这个说法最大的问题在于，完全违背了言文分离的原则，把两者当成相同的东西来看待了。在先秦时期，两者就是完全分离的。书面语是分析的，口语是综合的。</p><p>口语中是用声调或词缀来分辨不同意思的，两个词交换一下顺序，往往是不影响所表达的意思的。书面语中是顺序本身就能承担一定的语义，不需要类似词缀或者声调的东西来区分。书面语不需要像口语那样有从综合到分析的发展过程，书面语一开始就可以是高度分析的。西洋诸国的没有相对独立的书面语，把他们的理论生搬硬套到文言上肯定是行不通的。</p><p>也就是说，更合理的解释是，两者并行发展一段时间后，当时能留下来的是文字，而不是录音，所以在最初的几百年里，是书面语对口语的影响更大，而不是反过来。直到口语和书面语足够接近了，此时很难再坚持言文分离原则，书面语最终被口语反噬。到此时，历史的倒车就真正开起来了。</p><p>一个字可以表示名词的意思，也可以表示动词的意思，有些人就会抛出什么词类活用的说法。但是古人说话，更可能是一个声调表示一个词性，另一个声调表示另一个词性，写文章，更可能在句子的不同位置，表示不同的词性。一个字本来就承担两种词性，你是不能说这是活用的。<br></p><p>同样的倒装的说法，也是不成立的。一开始，就是规定，一个顺序表示肯定，另外一个顺序表示否定。合理的说法是肯定语序和否定语序。</p><p>而省略的说法更是不知道错到哪里去了。文言里极少有省略。假如意思是完整的，按你的语法却要说这里是省略，只能是你总结的语法错了，不可能是原文有省略。这个可以用支持type inference的程序语言来类比，支持type inference的程序语言，往往也是可以完全手工标注类型的，但是你不能说，我没有手工把所有类型都标上去，我程序的类型就一定是不完整的。假如能编译通过，那从语言的角度看，类型就是完整的。</p><p>我们学习文言，出发点是为了用。假如不能用，那还学个啥。于是，我们未必需要去考究历史上到底是怎么回事，哪怕我们的解释完全不符合历史事实，只要足够简单，很容易讲明白，而不是动不动就开特例，比如说这里是省略，能解释超过99.99%的内容，那就是可取的。</p><p>很遗憾，我们现在看到的解释，往往喜欢把字从句中剥离出来讲，喜欢套用西洋的拙劣语法。而我们真正需要的是，特例要尽可能少，能解释的内容尽可能多。我真的想不明白，类比成程序语言，文言不过是类型更丰富的APL，一点都不复杂的，怎么就都解释不清楚了？</p>",
            "image_url": "",
            "title": "历史是可以开倒车的",
            "excerpt_title": "",
            "excerpt": "<a href=\"https://zhuanlan.zhihu.com/p/24981621\" data-editable=\"true\" data-title=\"文言文到底脱胎于一种什么汉语\" class=\"\">文言文到底脱胎于一种什么汉语</a>中提出这种质疑是很有道理的，从「分析-综合」的这个类型角度来说，文言文的分析化程度太高，虚词占比过低，在世界上没有任何真实的语言是这么怪异的。这种分析化程度，甚至让不少人误以为古汉语曾经在达到了分析程度的顶峰之…"
        },
        {
            "type": "article",
            "updated": 1484664390,
            "id": 24928414,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1484664390,
            "url": "",
            "content": "<p><a href=\"https://zhuanlan.zhihu.com/p/24910829\" class=\"internal\">知乎专栏</a>  中提到</p><blockquote><p>因为这样的实现会更加麻烦一些，我将这个问题留给读者作为练习。 <br></p></blockquote><p> 然而，事实上无限+1要比在代码里设上限简单</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">Flag</span> <span class=\"p\">{</span>\n  <span class=\"k\">friend</span> <span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">flag</span><span class=\"p\">(</span><span class=\"n\">Flag</span><span class=\"p\">);</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">Writer</span> <span class=\"p\">{</span>\n  <span class=\"k\">friend</span> <span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">flag</span><span class=\"p\">(</span><span class=\"n\">Flag</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">return</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"o\">&gt;</span>\n<span class=\"k\">constexpr</span>\n<span class=\"kt\">int</span>\n<span class=\"n\">reader</span><span class=\"p\">(</span><span class=\"kt\">float</span><span class=\"p\">,</span> <span class=\"n\">Flag</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"p\">{})</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"n\">N</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span> <span class=\"n\">N</span><span class=\"o\">=</span><span class=\"mi\">0</span><span class=\"p\">,</span>\n         <span class=\"kt\">int</span> <span class=\"o\">=</span> <span class=\"n\">flag</span><span class=\"p\">(</span><span class=\"n\">Flag</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">{})</span>\n         <span class=\"o\">&gt;</span>\n<span class=\"k\">constexpr</span>\n<span class=\"kt\">int</span>\n<span class=\"n\">reader</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">Flag</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span> <span class=\"o\">=</span> <span class=\"p\">{},</span> <span class=\"kt\">int</span> <span class=\"n\">value</span> <span class=\"o\">=</span> <span class=\"n\">reader</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"n\">Flag</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">{}))</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"n\">value</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span> <span class=\"n\">N</span> <span class=\"o\">=</span> <span class=\"n\">reader</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">),</span>\n         <span class=\"kt\">int</span> <span class=\"o\">=</span> <span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">Writer</span><span class=\"o\">&lt;</span><span class=\"n\">N</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"o\">&gt;</span>\n<span class=\"k\">constexpr</span>\n<span class=\"kt\">int</span>\n<span class=\"n\">next</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"n\">N</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span>\n<span class=\"n\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">a</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"p\">();</span>\n  <span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">b</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"p\">();</span>\n  <span class=\"k\">constexpr</span> <span class=\"kt\">int</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">next</span><span class=\"p\">();</span>\n  <span class=\"k\">static_assert</span><span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"mi\">0</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">b</span> <span class=\"o\">==</span> <span class=\"n\">a</span> <span class=\"o\">+</span> <span class=\"mi\">1</span> <span class=\"o\">&amp;&amp;</span> <span class=\"n\">c</span> <span class=\"o\">==</span> <span class=\"n\">b</span> <span class=\"o\">+</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"s\">\"try again\"</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div>",
            "image_url": "",
            "title": "SMP之无限+1",
            "excerpt_title": "",
            "excerpt": "<a href=\"https://zhuanlan.zhihu.com/p/24910829\" class=\"internal\">知乎专栏</a> 中提到因为这样的实现会更加麻烦一些，我将这个问题留给读者作为练习。 然而，事实上无限+1要比在代码里设上限简单template&lt;int&gt;\nstruct Flag {\n friend constexpr int flag(Flag);\n};\n\ntemplate&lt;int N&gt;\nstruct Writer {\n friend constexpr int fl…"
        },
        {
            "type": "article",
            "updated": 1483441676,
            "id": 24694834,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1483441633,
            "url": "",
            "content": "<p>好了。第七期开始了。很遗憾，并不存在什么第七期，前几期都是烟幕弹。现在才是真正的内容。真正的内容很少，就下面那么一点点。</p><p>众所周知，C++的constexpr函数的返回值并不是真正完全不变的。 举个简单的例子，下面这个程序是编译不了的</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"err\">$</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"o\">=</span> <span class=\"k\">typename</span> <span class=\"err\">$</span><span class=\"o\">::</span><span class=\"n\">Lifetime</span><span class=\"o\">::</span><span class=\"n\">Ended</span><span class=\"o\">&gt;</span>\n<span class=\"k\">constexpr</span>\n<span class=\"kt\">bool</span>\n<span class=\"n\">ended</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nb\">true</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"err\">$</span><span class=\"o\">&gt;</span>\n<span class=\"k\">constexpr</span>\n<span class=\"kt\">bool</span>\n<span class=\"n\">ended</span><span class=\"p\">(...)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"nb\">false</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"kt\">int</span>\n<span class=\"n\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">struct</span> <span class=\"err\">$</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">Lifetime</span><span class=\"p\">;</span>\n  <span class=\"p\">};</span>\n\n  <span class=\"k\">static_assert</span><span class=\"p\">(</span><span class=\"n\">not</span> <span class=\"n\">ended</span><span class=\"o\">&lt;</span><span class=\"err\">$</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">));</span>\n\n  <span class=\"k\">struct</span> <span class=\"err\">$</span><span class=\"o\">::</span><span class=\"n\">Lifetime</span> <span class=\"p\">{</span>\n    <span class=\"k\">struct</span> <span class=\"n\">Ended</span><span class=\"p\">;</span>\n  <span class=\"p\">};</span>\n\n  <span class=\"k\">static_assert</span><span class=\"p\">(</span><span class=\"n\">not</span> <span class=\"n\">ended</span><span class=\"o\">&lt;</span><span class=\"err\">$</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">));</span> <span class=\"c1\">// compiler error here</span>\n<span class=\"p\">}</span>\n</code></pre></div><p><a href=\"https://link.zhihu.com/?target=http%3A//b.atch.se/posts/non-constant-constant-expressions/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Non-constant constant-expressions in C++<i class=\"icon-external\"></i></a>里介绍了著名的friend injection技巧。借此我们就可以在C++里模拟Rust的borrow checker</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;new&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;type_traits&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;utility&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">\"borrow.hpp\"</span><span class=\"cp\"></span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">Container</span> <span class=\"p\">{</span>\n  <span class=\"kt\">char</span> <span class=\"n\">buf</span><span class=\"p\">[</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"p\">)];</span>\n\n  <span class=\"kt\">void</span>\n  <span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">T</span> <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">));</span>\n    <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">)</span> <span class=\"n\">T</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">));</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">T</span>\n  <span class=\"nf\">read</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">T</span> <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">));</span>\n    <span class=\"n\">T</span> <span class=\"n\">item</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">);</span>\n    <span class=\"n\">ptr</span><span class=\"o\">-&gt;~</span><span class=\"n\">T</span><span class=\"p\">();</span>\n    <span class=\"k\">return</span> <span class=\"n\">item</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">T</span><span class=\"o\">&amp;</span>\n  <span class=\"n\">get</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"n\">T</span> <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">));</span>\n    <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">T</span> <span class=\"k\">const</span><span class=\"o\">&amp;</span>\n  <span class=\"n\">get</span><span class=\"p\">()</span> <span class=\"k\">const</span> <span class=\"p\">{</span>\n    <span class=\"n\">T</span> <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">T</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"kt\">void</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">));</span>\n    <span class=\"k\">return</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"err\">$</span><span class=\"p\">,</span>\n         <span class=\"kt\">bool</span> <span class=\"n\">A</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">borrow</span><span class=\"o\">::</span><span class=\"n\">available</span><span class=\"p\">(</span><span class=\"err\">$</span><span class=\"p\">{}),</span>\n         <span class=\"k\">typename</span> <span class=\"o\">=</span> <span class=\"k\">typename</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">enable_if</span><span class=\"o\">&lt;</span><span class=\"n\">A</span><span class=\"o\">&gt;::</span><span class=\"n\">type</span><span class=\"o\">&gt;</span>\n<span class=\"k\">auto</span>\n<span class=\"n\">get</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">borrow</span><span class=\"o\">::</span><span class=\"n\">BorrowPtr</span><span class=\"o\">&lt;</span><span class=\"n\">Container</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"err\">$</span><span class=\"o\">&gt;</span> <span class=\"n\">ptr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"o\">::</span><span class=\"n\">borrow</span><span class=\"o\">::</span><span class=\"n\">BorrowPtr</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"err\">$</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span> <span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">).</span><span class=\"n\">get</span><span class=\"p\">()</span> <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n\n\n<span class=\"kt\">int</span>\n<span class=\"n\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">auto</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">Container</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"o\">&gt;</span> <span class=\"p\">{};</span>\n  <span class=\"n\">c</span><span class=\"p\">.</span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"mi\">0</span><span class=\"p\">);</span>\n\n  <span class=\"n\">BEGIN_LIFETIME</span><span class=\"p\">(</span><span class=\"err\">$</span><span class=\"p\">);</span>\n  <span class=\"k\">auto</span> <span class=\"n\">p</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">borrow</span><span class=\"o\">::</span><span class=\"n\">borrow_mut</span><span class=\"o\">&lt;</span><span class=\"err\">$</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">c</span><span class=\"p\">);</span>\n\n  <span class=\"n\">BEGIN_LIFETIME</span><span class=\"p\">(</span><span class=\"err\">$</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n  <span class=\"k\">auto</span> <span class=\"n\">p1</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">borrow</span><span class=\"o\">::</span><span class=\"n\">borrow_mut</span><span class=\"o\">&lt;</span><span class=\"err\">$</span><span class=\"mi\">1</span><span class=\"o\">&gt;</span><span class=\"p\">(</span><span class=\"n\">p</span><span class=\"p\">);</span>\n\n  <span class=\"k\">auto</span> <span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"n\">get</span><span class=\"p\">(</span><span class=\"n\">p1</span><span class=\"p\">);</span>\n\n  <span class=\"o\">*</span><span class=\"n\">p2</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n  <span class=\"n\">END_LIFETIME</span><span class=\"p\">(</span><span class=\"err\">$</span><span class=\"mi\">1</span><span class=\"p\">);</span>\n\n  <span class=\"o\">*</span><span class=\"n\">p2</span><span class=\"p\">;</span> <span class=\"c1\">// compiler error here</span>\n\n  <span class=\"n\">END_LIFETIME</span><span class=\"p\">(</span><span class=\"err\">$</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在 $1 结束之后，p1 p2就都用不了了。你要想用就会产生编译错误。</p><p>难以置信，这就是编译不过去。那么就到此为止吧。</p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++ (7)",
            "excerpt_title": "",
            "excerpt": "好了。第七期开始了。很遗憾，并不存在什么第七期，前几期都是烟幕弹。现在才是真正的内容。真正的内容很少，就下面那么一点点。众所周知，C++的constexpr函数的返回值并不是真正完全不变的。 举个简单的例子，下面这个程序是编译不了的template&lt;typename $…"
        },
        {
            "type": "article",
            "updated": 1483431315,
            "id": 24693000,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1483431316,
            "url": "",
            "content": "<p>看了这么多期。你肯定早就发现了，这个系列就是个标题党。除了标题和轮子哥并没有半毛钱关系。而且和C++关系也不大。</p><p>没错。我写的这些实际上是，怎么让C++和Rust代码尽量直接对应。</p><p>本期就相当于回顾一下前几期的内容。 <br></p><p>就举一个非常简单的例子<br></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">namespace</span> <span class=\"n\">storage</span> <span class=\"p\">{</span>\n\n  <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"o\">=</span> <span class=\"kt\">void</span><span class=\"o\">&gt;</span> <span class=\"k\">struct</span> <span class=\"n\">SystemAllocator</span><span class=\"p\">;</span>\n\n  <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n  <span class=\"k\">struct</span> <span class=\"n\">SystemAllocator</span><span class=\"o\">&lt;</span>\n      <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">enable_if</span><span class=\"o\">&lt;::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">is_nothrow_move_constructible</span><span class=\"o\">&lt;</span>\n             <span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">value</span> <span class=\"o\">&amp;&amp;</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">is_nothrow_destructible</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">value</span><span class=\"o\">&gt;::</span><span class=\"n\">type</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n    <span class=\"n\">SystemAllocator</span><span class=\"p\">(</span><span class=\"n\">SystemAllocator</span> <span class=\"k\">const</span> <span class=\"o\">&amp;</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">delete</span><span class=\"p\">;</span>\n    <span class=\"n\">SystemAllocator</span> <span class=\"o\">&amp;</span>\n    <span class=\"k\">operator</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">SystemAllocator</span> <span class=\"k\">const</span> <span class=\"o\">&amp;</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">delete</span><span class=\"p\">;</span>\n\n    <span class=\"n\">SystemAllocator</span><span class=\"p\">(</span><span class=\"n\">SystemAllocator</span> <span class=\"o\">&amp;&amp;</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">default</span><span class=\"p\">;</span>\n  <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">namespace</span> <span class=\"n\">traits</span> <span class=\"p\">{</span>\n\n  <span class=\"k\">template</span> <span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n  <span class=\"k\">struct</span> <span class=\"n\">Allocator</span><span class=\"o\">::</span><span class=\"n\">Impl</span><span class=\"o\">&lt;::</span><span class=\"n\">ttl</span><span class=\"o\">::</span><span class=\"n\">storage</span><span class=\"o\">::</span><span class=\"n\">SystemAllocator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">private</span><span class=\"o\">:</span>\n    <span class=\"k\">using</span> <span class=\"n\">SystemAllocator</span> <span class=\"o\">=</span> <span class=\"o\">::</span><span class=\"n\">ttl</span><span class=\"o\">::</span><span class=\"n\">storage</span><span class=\"o\">::</span><span class=\"n\">SystemAllocator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n\n  <span class=\"k\">public</span><span class=\"o\">:</span>\n    <span class=\"k\">using</span> <span class=\"n\">Item</span> <span class=\"o\">=</span> <span class=\"n\">T</span><span class=\"p\">;</span>\n\n    <span class=\"k\">static</span> <span class=\"n\">Item</span> <span class=\"o\">*</span>\n    <span class=\"nf\">add</span><span class=\"p\">(</span><span class=\"n\">SystemAllocator</span> <span class=\"o\">&amp;</span><span class=\"p\">,</span> <span class=\"n\">Item</span> <span class=\"o\">&amp;&amp;</span><span class=\"n\">item</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">Item</span> <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"k\">static_cast</span><span class=\"o\">&lt;</span><span class=\"n\">Item</span> <span class=\"o\">*&gt;</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">Item</span><span class=\"p\">)));</span>\n      <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">)</span> <span class=\"n\">Item</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">item</span><span class=\"p\">));</span>\n      <span class=\"k\">return</span> <span class=\"n\">ptr</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"k\">static</span> <span class=\"n\">Item</span>\n    <span class=\"nf\">remove</span><span class=\"p\">(</span><span class=\"n\">SystemAllocator</span> <span class=\"o\">&amp;</span><span class=\"p\">,</span> <span class=\"n\">Item</span> <span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">Item</span> <span class=\"n\">item</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">));</span>\n      <span class=\"n\">ptr</span><span class=\"o\">-&gt;~</span><span class=\"n\">Item</span><span class=\"p\">();</span>\n      <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span>\n      <span class=\"k\">return</span> <span class=\"n\">item</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">};</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>在Rust里是这么写的。</p><div class=\"highlight\"><pre><code class=\"language-rust\"><span></span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">struct</span><span class=\"w\"> </span><span class=\"n\">SystemAllocator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"n\">_marker</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhantomData</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">,</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">Allocator</span><span class=\"w\"> </span><span class=\"k\">for</span><span class=\"w\"> </span><span class=\"n\">SystemAllocator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">type</span><span class=\"w\"> </span><span class=\"n\">Item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">add</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">size</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">size_of</span><span class=\"o\">::&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">();</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">malloc</span><span class=\"p\">(</span><span class=\"n\">size</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">;</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">write</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">ptr</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"w\">    </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">remove</span><span class=\"p\">(</span><span class=\"o\">&amp;</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"bp\">self</span><span class=\"p\">,</span><span class=\"w\"> </span><span class=\"n\">ptr</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"p\">)</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">T</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"k\">unsafe</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"kd\">let</span><span class=\"w\"> </span><span class=\"n\">item</span><span class=\"w\"> </span><span class=\"o\">=</span><span class=\"w\"> </span><span class=\"n\">read</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">free</span><span class=\"p\">(</span><span class=\"n\">ptr</span><span class=\"w\"> </span><span class=\"k\">as</span><span class=\"w\"> </span><span class=\"o\">*</span><span class=\"k\">mut</span><span class=\"w\"> </span><span class=\"kt\">u8</span><span class=\"p\">);</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">item</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n\n<span class=\"k\">impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"n\">SystemAllocator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"k\">pub</span><span class=\"w\"> </span><span class=\"k\">fn</span><span class=\"w\"> </span><span class=\"n\">new</span><span class=\"p\">()</span><span class=\"w\"> </span><span class=\"o\">-&gt;</span><span class=\"w\"> </span><span class=\"n\">Self</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"n\">SystemAllocator</span><span class=\"w\"> </span><span class=\"p\">{</span><span class=\"w\"></span>\n<span class=\"w\">            </span><span class=\"n\">_marker</span><span class=\"o\">:</span><span class=\"w\"> </span><span class=\"n\">PhantomData</span><span class=\"w\"></span>\n<span class=\"w\">        </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"w\">    </span><span class=\"p\">}</span><span class=\"w\"></span>\n<span class=\"p\">}</span><span class=\"w\"></span>\n</code></pre></div><p>本期到此结束</p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++ (6)",
            "excerpt_title": "",
            "excerpt": "看了这么多期。你肯定早就发现了，这个系列就是个标题党。除了标题和轮子哥并没有半毛钱关系。而且和C++关系也不大。没错。我写的这些实际上是，怎么让C++和Rust代码尽量直接对应。本期就相当于回顾一下前几期的内容。 就举一个非常简单的例子 namespace st…"
        },
        {
            "type": "article",
            "updated": 1483244520,
            "id": 24661323,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1483197802,
            "url": "",
            "content": "<p>说的就是你，<a href=\"https://www.zhihu.com/people/b6f0c45a4d0dc84f228977e0d70bd700\" data-hash=\"b6f0c45a4d0dc84f228977e0d70bd700\" class=\"member_mention\" data-title=\"@立党  \" data-editable=\"true\" data-hovercard=\"p$b$b6f0c45a4d0dc84f228977e0d70bd700\">@立党  </a>:  <a href=\"https://zhuanlan.zhihu.com/p/24600717\" class=\"internal\">穷逼就别学单片机开发了</a></p><p>CSAPP这过气的大杂烩有啥好推荐的。 作为大杂烩也是不及格的，大杂烩追求的是覆盖面广，去讲什么优化之类的深度内容是什么意思？</p><p>之前我提到过 <a href=\"https://zhuanlan.zhihu.com/p/23881270\" class=\"internal\">If you can't do, teach.</a> ，不过最后光顾着打( <a href=\"https://link.zhihu.com/?target=https%3A//fast-track.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">伪书<i class=\"icon-external\"></i></a> ) 广告，没有考虑实际情况，推荐一些可以立即动手做起来的想法。现在就来推荐一下</p><p>------------------------------------------------------ <br></p><p>Linux有了namespace之后，网络搞起来就方便了很多，不怕把在用的网络配置玩坏了。可以参考 <a href=\"https://link.zhihu.com/?target=https%3A//github.com/mininet\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Mininet<i class=\"icon-external\"></i></a> 。我希望是先建一个user namespace，这样就不需要root权限了。内容有多少搞多少吧，可以怎么搭一个什么样的网络开始，或者怎么在tun/tap上实现个网络协议栈，或者找个交换机厂家提供公开下载的的模拟器软件，连到这个network namespace里。</p><p>------------------------------------------------------  <br></p><p>操作系统不只是内核，其他功能也很重要。 Linux有了UIO/VFIO之后，也是可以比较方便的开发用户态驱动了。而qemu是可以直接用 -kernel 参数启动的，也就是我们可以利用宿主机上已经安装的内核来启动虚拟机，免去很多麻烦，搞个只有busybox的initramfs，当然如果缺一些模块也要放进去，起来就别去pivot root了，mount一个9p FS就直接访问宿主机上的文件了。这样后面开发驱动就比较方便了。你可以试着用这样的方法，开发一个用户态驱动。</p><p>------------------------------------------------------</p><p>新一代的像Wayland这样的display server，接口是比较简单的。我们直接申请一片内存，往里写每个点的颜色值就好了，不需要纠缠别的东西。所以搞一个演示OpenGL原理的程序。用软件大概模拟一下GPU画图的过程，注意一定不要搞成软渲染那样。大概样子，应该长的和<a href=\"https://link.zhihu.com/?target=https%3A//github.com/bhuztez/triangle\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">triangle<i class=\"icon-external\"></i></a>里的draw.cpp差不多。不过那里面代码写的比较乱，画图的时候画蛇添足多算了个bounding box，不可取，例子可能也是错的。不管怎么样，图能画出来了。假如你觉得还能忍，那么就把这些问题改改好。不能忍直接从头写个更好的吧。<br></p><p>------------------------------------------------------</p><p>别的想起来再补充。或者你有一些像上面这样不太完整的想法，也可以在评论里说。我会搬运上来的。 </p>",
            "image_url": "",
            "title": "别推荐什么CSAPP了",
            "excerpt_title": "",
            "excerpt": "说的就是你，<a href=\"https://www.zhihu.com/people/b6f0c45a4d0dc84f228977e0d70bd700\" data-hash=\"b6f0c45a4d0dc84f228977e0d70bd700\" class=\"member_mention\" data-title=\"@立党  \" data-editable=\"true\" data-hovercard=\"p$b$b6f0c45a4d0dc84f228977e0d70bd700\">@立党 </a>: <a href=\"https://zhuanlan.zhihu.com/p/24600717\" data-editable=\"true\" data-title=\"穷逼就别学单片机开发了\" class=\"\">穷逼就别学单片机开发了</a>CSAPP这过气的大杂烩有啥好推荐的。 作为大杂烩也是不及格的，大杂烩追求的是覆盖面广，去讲什么优化之类的深度内容是什么意思？之前我提到过 <a href=\"https://zhuanlan.zhihu.com/p/23881270\" data-editable=\"true\" data-title=\"知乎专栏\" class=\"\">If you can't do, teach.</a> ，不过最后光顾着打( <a href=\"https://fast-track.github.io/\" data-editable=\"true\" data-title=\"广告\" class=\"\">伪书</a> ) 广告，没有考…"
        },
        {
            "type": "article",
            "updated": 1483109247,
            "id": 24643171,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1483109247,
            "url": "",
            "content": "<p>本期就讲一点点和 rvalue reference有关的东西。C++的 ::std::move 这个名字有很强的欺骗性。::std::move并不能把内容move走。只是搞出了个rvalue reference，真正的move是在move constructor里完成的。这样造成了一些不必要的麻烦，虽然你已经move走了，但是原来那里destructor还是会照常调用的。毕竟这个叫rvalue reference而不是rvalue。</p><p>现在就来检验一下对move的理解。我们用valid来标记有没有move走。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">struct</span> <span class=\"n\">Counter</span> <span class=\"p\">{</span>\n  <span class=\"k\">static</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kt\">size_t</span> <span class=\"n\">count</span><span class=\"p\">;</span>\n  <span class=\"kt\">bool</span> <span class=\"n\">valid</span><span class=\"p\">;</span>\n\n  <span class=\"n\">Counter</span><span class=\"p\">()</span> <span class=\"o\">:</span> <span class=\"n\">valid</span><span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">Counter</span><span class=\"o\">&amp;&amp;</span><span class=\"n\">o</span><span class=\"p\">)</span> <span class=\"k\">noexcept</span> <span class=\"o\">:</span> <span class=\"n\">valid</span><span class=\"p\">(</span><span class=\"nb\">false</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">swap</span><span class=\"p\">(</span><span class=\"n\">valid</span><span class=\"p\">,</span> <span class=\"n\">o</span><span class=\"p\">.</span><span class=\"n\">valid</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">Counter</span><span class=\"o\">&amp;</span> <span class=\"k\">operator</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"n\">Counter</span><span class=\"o\">&amp;&amp;</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">delete</span><span class=\"p\">;</span>\n\n  <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"n\">Counter</span> <span class=\"k\">const</span><span class=\"o\">&amp;</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">delete</span><span class=\"p\">;</span>\n  <span class=\"n\">Counter</span><span class=\"o\">&amp;</span> <span class=\"k\">operator</span><span class=\"o\">=</span><span class=\"p\">(</span><span class=\"k\">const</span> <span class=\"n\">Counter</span><span class=\"o\">&amp;</span><span class=\"p\">)</span> <span class=\"o\">=</span> <span class=\"k\">delete</span><span class=\"p\">;</span>\n\n  <span class=\"o\">~</span><span class=\"n\">Counter</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">valid</span><span class=\"p\">)</span>\n      <span class=\"n\">count</span><span class=\"o\">++</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"kt\">size_t</span> <span class=\"n\">Counter</span><span class=\"o\">::</span><span class=\"n\">count</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n</code></pre></div><p>我们写的没错，那么下面这段代码的输出就应该是1</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"kt\">char</span> <span class=\"n\">buf</span><span class=\"p\">[</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">Counter</span><span class=\"p\">)]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"mi\">0</span><span class=\"p\">};</span>\n\n<span class=\"kt\">void</span>\n<span class=\"nf\">write</span><span class=\"p\">(</span><span class=\"n\">Counter</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">counter</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">new</span> <span class=\"p\">(</span><span class=\"n\">buf</span><span class=\"p\">)</span> <span class=\"n\">Counter</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"n\">counter</span><span class=\"p\">));</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">Counter</span>\n<span class=\"nf\">read</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"n\">Counter</span> <span class=\"o\">*</span><span class=\"n\">ptr</span> <span class=\"o\">=</span> <span class=\"p\">(</span><span class=\"n\">Counter</span> <span class=\"o\">*</span><span class=\"p\">)</span><span class=\"n\">buf</span><span class=\"p\">;</span>\n  <span class=\"n\">Counter</span> <span class=\"n\">counter</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">move</span><span class=\"p\">(</span><span class=\"o\">*</span><span class=\"n\">ptr</span><span class=\"p\">));</span>\n  <span class=\"n\">ptr</span><span class=\"o\">-&gt;~</span><span class=\"n\">Counter</span><span class=\"p\">();</span>\n  <span class=\"k\">return</span> <span class=\"n\">counter</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span>\n<span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"p\">{</span>\n    <span class=\"n\">write</span><span class=\"p\">({});</span>\n    <span class=\"n\">Counter</span> <span class=\"n\">c</span> <span class=\"o\">=</span> <span class=\"n\">read</span><span class=\"p\">();</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%zu</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">,</span> <span class=\"n\">Counter</span><span class=\"o\">::</span><span class=\"n\">count</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>也就是从写进去到读出来，我们没有主动产生不必要的东西。</p><p>假如是一个引用计数的，我们采用copy语义，count就不止是1了，也就是这里引用计数会多几次不必要的+1 -1，这样很不好。</p><p>本期内容比较少，就到此结束吧。</p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++ (5)",
            "excerpt_title": "",
            "excerpt": "本期就讲一点点和 rvalue reference有关的东西。C++的 ::std::move 这个名字有很强的欺骗性。::std::move并不能把内容move走。只是搞出了个rvalue reference，真正的move是在move constructor里完成的。这样造成了一些不必要的麻烦，虽然你已经move走了，但…"
        },
        {
            "type": "article",
            "updated": 1483109158,
            "id": 24640224,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1483109134,
            "url": "",
            "content": "<p>这一期我们就来看一点点 printf 的问题。现在整数类型都用 uint8_t 这种，可是printf不支持啊。</p><p>用模板表示字符串，我们用额外的STRING_LITERAL将字符串存下来，免得编译器一不高兴就把所有中间产生的字符串都存下来。<br></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">...</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">STRING</span> <span class=\"p\">{</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">STRING_LITERAL</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">...</span> <span class=\"n\">S</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">STRING_LITERAL</span><span class=\"o\">&lt;</span><span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">static</span> <span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"n\">s</span><span class=\"p\">[</span><span class=\"k\">sizeof</span><span class=\"p\">...(</span><span class=\"n\">S</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">];</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">...</span> <span class=\"n\">S</span><span class=\"o\">&gt;</span>\n<span class=\"k\">const</span> <span class=\"kt\">char</span> <span class=\"n\">STRING_LITERAL</span><span class=\"o\">&lt;</span><span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;&gt;::</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"k\">sizeof</span><span class=\"p\">...(</span><span class=\"n\">S</span><span class=\"p\">)</span><span class=\"o\">+</span><span class=\"mi\">1</span><span class=\"p\">]</span> <span class=\"o\">=</span> <span class=\"p\">{</span><span class=\"n\">S</span><span class=\"p\">...,</span> <span class=\"mi\">0</span><span class=\"p\">};</span>\n</code></pre></div><p>通过模板的功能，我们能将不同的整数类型，对应到不同的格式字符串。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">MOD</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">MOD</span><span class=\"o\">&lt;</span><span class=\"kt\">unsigned</span> <span class=\"kt\">char</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"sc\">'h'</span><span class=\"p\">,</span> <span class=\"sc\">'h'</span><span class=\"p\">,</span> <span class=\"sc\">'u'</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">MOD</span><span class=\"o\">&lt;</span><span class=\"kt\">unsigned</span> <span class=\"kt\">short</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"sc\">'h'</span><span class=\"p\">,</span> <span class=\"sc\">'u'</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p> 这里用 `8u 表示 uint8_t，`8d 表示 int8_t，类似的这里就省略了</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">struct</span> <span class=\"n\">CONCAT</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">...</span> <span class=\"n\">S1</span><span class=\"p\">,</span> <span class=\"kt\">char</span><span class=\"p\">...</span> <span class=\"n\">S2</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">CONCAT</span><span class=\"o\">&lt;</span><span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"n\">S1</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"n\">S2</span><span class=\"p\">...</span><span class=\"o\">&gt;&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"n\">S1</span><span class=\"p\">...,</span> <span class=\"n\">S2</span><span class=\"p\">...</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">...</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">CONVERT</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"n\">STRING</span><span class=\"o\">&lt;&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">...</span> <span class=\"n\">S</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"sc\">'`'</span><span class=\"p\">,</span> <span class=\"sc\">'`'</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"k\">typename</span> <span class=\"n\">CONCAT</span><span class=\"o\">&lt;</span><span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"sc\">'`'</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">...</span> <span class=\"n\">S</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"sc\">'`'</span><span class=\"p\">,</span> <span class=\"sc\">'8'</span><span class=\"p\">,</span> <span class=\"sc\">'u'</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"k\">typename</span> <span class=\"n\">CONCAT</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">MOD</span><span class=\"o\">&lt;</span><span class=\"kt\">uint8_t</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span><span class=\"p\">...</span> <span class=\"n\">S</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"sc\">'`'</span><span class=\"p\">,</span> <span class=\"sc\">'8'</span><span class=\"p\">,</span> <span class=\"sc\">'d'</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"k\">typename</span> <span class=\"n\">CONCAT</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">MOD</span><span class=\"o\">&lt;</span><span class=\"kt\">int8_t</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"kt\">char</span> <span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"kt\">char</span><span class=\"p\">...</span> <span class=\"n\">S</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"n\">C</span><span class=\"p\">,</span> <span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"k\">typename</span> <span class=\"n\">CONCAT</span><span class=\"o\">&lt;</span><span class=\"n\">STRING</span><span class=\"o\">&lt;</span><span class=\"n\">C</span><span class=\"o\">&gt;</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">...</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>最后包装一下</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">,</span> <span class=\"k\">typename</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">MAKE_STRING</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">U</span><span class=\"p\">,</span> <span class=\"n\">U</span><span class=\"p\">...</span><span class=\"o\">&gt;</span> <span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">U</span><span class=\"p\">,</span> <span class=\"n\">U</span><span class=\"p\">...</span> <span class=\"n\">I</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">MAKE_STRING</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"n\">T</span><span class=\"o\">&lt;</span><span class=\"n\">U</span><span class=\"p\">,</span> <span class=\"n\">I</span><span class=\"p\">...</span><span class=\"o\">&gt;&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">using</span> <span class=\"n\">TYPE</span> <span class=\"o\">=</span> <span class=\"k\">typename</span> <span class=\"n\">CONVERT</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">{}.</span><span class=\"n\">s</span><span class=\"p\">[</span><span class=\"n\">I</span><span class=\"p\">]...</span><span class=\"o\">&gt;::</span><span class=\"n\">TYPE</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">S</span><span class=\"o\">&gt;</span>\n<span class=\"k\">using</span> <span class=\"n\">FORMAT_STRING</span> <span class=\"o\">=</span> <span class=\"n\">STRING_LITERAL</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">MAKE_STRING</span><span class=\"o\">&lt;</span><span class=\"n\">S</span><span class=\"p\">,</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">make_index_sequence</span><span class=\"o\">&lt;</span><span class=\"k\">sizeof</span><span class=\"p\">(</span><span class=\"n\">S</span><span class=\"p\">)</span><span class=\"o\">-</span><span class=\"mi\">1</span><span class=\"o\">&gt;&gt;::</span><span class=\"n\">TYPE</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n\n<span class=\"cp\">#define FORMAT(str) ({ struct S { const char s[sizeof(str)] = (str); }; FORMAT_STRING&lt;S&gt;::s;})</span>\n</code></pre></div><p>于是就可以这么用了</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span>  <span class=\"kt\">uint8_t</span> <span class=\"n\">x</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n  <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"n\">FORMAT</span><span class=\"p\">(</span><span class=\"s\">\"``%`8u</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">),</span> <span class=\"n\">x</span><span class=\"p\">);</span>\n</code></pre></div><p>本期就到此结束了</p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++ (4)",
            "excerpt_title": "",
            "excerpt": "这一期我们就来看一点点 printf 的问题。现在整数类型都用 uint8_t 这种，可是printf不支持啊。用模板表示字符串，我们用额外的STRING_LITERAL将字符串存下来，免得编译器一不高兴就把所有中间产生的字符串都存下来。 template&lt;char...&gt;\nstruct STRING {\n};…"
        },
        {
            "type": "article",
            "updated": 1482655907,
            "id": 24553653,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1482655412,
            "url": "",
            "content": "<p>根据前两期的内容，我想你们一定猜到了，这一期我们会转进到和<a href=\"https://link.zhihu.com/?target=https%3A//en.wikipedia.org/wiki/Abstract_data_type\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Abstract data type<i class=\"icon-external\"></i></a>相关的内容。毕竟解决了allocator的类型问题之后，我们就应该来看一看container接口的问题。</p><p>C++现在的STL很不好，把Abstract Data Type的操作都写在具体实现里。假如一个container既实现了Stack又实现了Queue，那么请问 container.push 究竟是Stack的push还是Queue的push?<br></p><p>所以接下来，我们来看一点点<a href=\"https://link.zhihu.com/?target=https%3A//github.com/pfultz2/Tick/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> pfultz2/Tick<i class=\"icon-external\"></i></a> 的原理，实现一个naive的Trait机制。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"p\">...</span><span class=\"n\">Args</span><span class=\"o\">&gt;</span>\n<span class=\"k\">using</span> <span class=\"n\">VOID</span> <span class=\"o\">=</span> <span class=\"kt\">void</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"p\">,</span> <span class=\"k\">typename</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">SAME_TYPE</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">SAME_TYPE</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span> <span class=\"n\">Trait</span><span class=\"o\">&gt;</span>\n<span class=\"k\">using</span> <span class=\"n\">IMPLEMENTS</span> <span class=\"o\">=</span> <span class=\"k\">decltype</span><span class=\"p\">(</span><span class=\"n\">Trait</span><span class=\"o\">::</span><span class=\"k\">template</span> <span class=\"n\">REQUIRE</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">());</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">MyFirstTrait</span> <span class=\"p\">{</span>\n  <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n  <span class=\"k\">struct</span> <span class=\"n\">Impl</span><span class=\"p\">;</span>\n\n  <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n  <span class=\"k\">static</span>\n  <span class=\"kt\">void</span>\n  <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;</span> <span class=\"n\">self</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">Impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">self</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n  <span class=\"k\">constexpr</span>\n  <span class=\"k\">static</span>\n  <span class=\"k\">auto</span>\n  <span class=\"n\">REQUIRE</span><span class=\"p\">()</span> <span class=\"o\">-&gt;</span> <span class=\"n\">VOID</span><span class=\"o\">&lt;</span>\n    <span class=\"n\">SAME_TYPE</span><span class=\"o\">&lt;</span><span class=\"k\">decltype</span><span class=\"p\">(</span><span class=\"n\">Impl</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;::</span><span class=\"n\">f</span><span class=\"p\">),</span> <span class=\"k\">decltype</span><span class=\"p\">(</span><span class=\"n\">f</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span><span class=\"p\">)</span><span class=\"o\">&gt;</span>\n    <span class=\"o\">&gt;</span><span class=\"p\">;</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>比如我们有两个struct，一个实现了MyFirstTrait，一个没有实现</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">struct</span> <span class=\"n\">Foo</span> <span class=\"p\">{</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">MyFirstTrait</span><span class=\"o\">::</span><span class=\"n\">Impl</span><span class=\"o\">&lt;</span><span class=\"n\">Foo</span><span class=\"o\">&gt;</span> <span class=\"p\">{</span>\n  <span class=\"k\">static</span>\n  <span class=\"kt\">void</span>\n  <span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">Foo</span><span class=\"o\">&amp;</span> <span class=\"n\">self</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">struct</span> <span class=\"n\">Bar</span> <span class=\"p\">{</span>\n<span class=\"p\">};</span>\n</code></pre></div><p>那一个函数怎么针对不同的trait有不同的实现？</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;utility&gt;</span><span class=\"cp\"></span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span><span class=\"o\">=</span><span class=\"kt\">void</span><span class=\"o\">&gt;</span>\n<span class=\"k\">constexpr</span>\n<span class=\"kt\">int</span> <span class=\"n\">_test</span> <span class=\"o\">=</span> <span class=\"mi\">0</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">constexpr</span>\n<span class=\"kt\">int</span> <span class=\"n\">_test</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">IMPLEMENTS</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">MyFirstTrait</span><span class=\"o\">&gt;&gt;</span> <span class=\"o\">=</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">typename</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">enable_if</span><span class=\"o\">&lt;</span><span class=\"n\">_test</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">==</span> <span class=\"mi\">0</span><span class=\"p\">,</span> <span class=\"kt\">void</span><span class=\"o\">&gt;::</span><span class=\"n\">type</span>\n<span class=\"n\">test</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"0</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">typename</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">enable_if</span><span class=\"o\">&lt;</span><span class=\"n\">_test</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;</span> <span class=\"o\">==</span> <span class=\"mi\">1</span><span class=\"p\">,</span> <span class=\"kt\">void</span><span class=\"o\">&gt;::</span><span class=\"n\">type</span>\n<span class=\"n\">test</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"n\">MyFirstTrait</span><span class=\"o\">::</span><span class=\"n\">f</span><span class=\"p\">(</span><span class=\"n\">x</span><span class=\"p\">);</span>\n  <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"1</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span>\n<span class=\"n\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"n\">test</span><span class=\"p\">(</span><span class=\"n\">Foo</span> <span class=\"p\">{});</span>\n  <span class=\"n\">test</span><span class=\"p\">(</span><span class=\"n\">Bar</span> <span class=\"p\">{});</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>如何让编译器拒绝没有实现某个Trait的类型？</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"n\">IMPLEMENTS</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">MyFirstTrait</span><span class=\"o\">&gt;</span>\n<span class=\"n\">fail</span><span class=\"p\">(</span><span class=\"n\">T</span><span class=\"o\">&amp;&amp;</span> <span class=\"n\">x</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span>\n<span class=\"n\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"n\">fail</span><span class=\"p\">(</span><span class=\"n\">Foo</span> <span class=\"p\">{});</span>\n  <span class=\"n\">fail</span><span class=\"p\">(</span><span class=\"n\">Bar</span> <span class=\"p\">{});</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>本期内容非常简单，就到此结束吧。</p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++ (3)",
            "excerpt_title": "",
            "excerpt": "根据前两期的内容，我想你们一定猜到了，这一期我们会转进到和<a href=\"https://en.wikipedia.org/wiki/Abstract_data_type\" data-editable=\"true\" data-title=\"Abstract data type\" class=\"\">Abstract data type</a>相关的内容。毕竟解决了allocator的类型问题之后，我们就应该来看一看container接口的问题。C++现在的STL很不好，把Abstract Data Type的操作都写在具体实现里。假如一个cont…"
        },
        {
            "type": "article",
            "updated": 1482591025,
            "id": 24547564,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1482590297,
            "url": "",
            "content": "<p>有很多人对<a href=\"https://zhuanlan.zhihu.com/p/24535431\" class=\"internal\"> 教轮子哥学一点点C++ (1)</a> 提出疑问，表示不理解这篇文章，认为这么简单达不到劝退的效果。</p><p>真的是这样的吗？我说过，这个系列是要用轮子哥的方式来劝退C++。什么是轮子哥的方式？那就是造轮子啊。假如你之前没有造过类似的轮子，看完之后也没想自己动手造一个，这只能说明你已经放弃C++了。我们的文章卓有成效。从这个开始，主要是因为C++标准库里并没有测试工具，所以我们得先自制一个。顺便还能黑轮子哥还在用石器时代之前的测试方式，多好。</p><p>假如你坚持认为自己还没放弃，只是不知道要造个什么样的轮子。好，那我来给你一个例子<br></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdexcept&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">\"test.hpp\"</span><span class=\"cp\"></span>\n\n<span class=\"kt\">bool</span>\n<span class=\"nf\">is_equal</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">a</span><span class=\"p\">,</span> <span class=\"kt\">int</span> <span class=\"n\">b</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"k\">return</span> <span class=\"p\">(</span><span class=\"n\">a</span> <span class=\"o\">==</span> <span class=\"n\">b</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n\n<span class=\"n\">TESTCASE</span><span class=\"p\">(</span><span class=\"s\">\"My First TestCase\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n\n  <span class=\"n\">SECTION</span><span class=\"p\">(</span><span class=\"s\">\"No problem\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"nb\">true</span><span class=\"p\">);</span>\n    <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"n\">is_equal</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">1</span><span class=\"p\">));</span>\n    <span class=\"n\">ASSERT_THROW</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"k\">throw</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">SECTION</span><span class=\"p\">(</span><span class=\"s\">\"Assertion failed\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">SECTION</span><span class=\"p\">(</span><span class=\"s\">\"a\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"nb\">false</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">SECTION</span><span class=\"p\">(</span><span class=\"s\">\"b\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"n\">ASSERT</span><span class=\"p\">(</span><span class=\"n\">is_equal</span><span class=\"p\">(</span><span class=\"mi\">1</span><span class=\"p\">,</span><span class=\"mi\">2</span><span class=\"p\">));</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">SECTION</span><span class=\"p\">(</span><span class=\"s\">\"c\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">ASSERT_THROW</span><span class=\"p\">(</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"mi\">1</span><span class=\"p\">);</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"n\">SECTION</span><span class=\"p\">(</span><span class=\"s\">\"Exceptions\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"n\">SECTION</span><span class=\"p\">(</span><span class=\"s\">\"a\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">throw</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n    <span class=\"p\">}</span>\n\n    <span class=\"n\">SECTION</span><span class=\"p\">(</span><span class=\"s\">\"b\"</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n      <span class=\"k\">throw</span> <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">logic_error</span><span class=\"p\">(</span><span class=\"s\">\"stop here\"</span><span class=\"p\">);</span>\n    <span class=\"p\">}</span>\n  <span class=\"p\">}</span>\n\n<span class=\"p\">}</span>\n\n<span class=\"kt\">int</span>\n<span class=\"n\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"o\">!</span><span class=\"n\">run_tests</span><span class=\"p\">())</span>\n    <span class=\"k\">return</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>请提供 test.hpp ，使得输出差不多长下面这样</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>Caught exception of type 'AssertionFailure'\ntestcase.cpp:19: ASSERTION FAILED\n  false\nTestcase state:\n   testcase.cpp:9: My First TestCase\n      testcase.cpp:17: Assertion failed\n      -&gt; testcase.cpp:18: a\nCaught exception of type 'AssertionFailure'\ntestcase.cpp:23: ASSERTION FAILED\n  is_equal(1,2)\nTestcase state:\n   testcase.cpp:9: My First TestCase\n      testcase.cpp:17: Assertion failed\n      -&gt; testcase.cpp:22: b\nCaught exception of type 'AssertionFailure'\ntestcase.cpp:29: No exception caught in\n  1\nTestcase state:\n   testcase.cpp:9: My First TestCase\n   -&gt; testcase.cpp:17: Assertion failed\n         testcase.cpp:26: c\nCaught exception of type 'AssertionFailure'\ntestcase.cpp:29: No exception caught in\n  1\nTestcase state:\n   testcase.cpp:9: My First TestCase\n   -&gt; testcase.cpp:17: Assertion failed\nCaught exception of type 'int'\nTestcase state:\n   testcase.cpp:9: My First TestCase\n      testcase.cpp:32: Exceptions\n      -&gt; testcase.cpp:33: a\nCaught exception of type 'std::logic_error'\n  stop here\nTestcase state:\n   testcase.cpp:9: My First TestCase\n      testcase.cpp:32: Exceptions\n      -&gt; testcase.cpp:37: b\nResult: 3/9 passed\n</code></pre></div><p>编译请用 g++ -std=gnu++14 -o testcase testcase.cpp</p><p>假如你想证明你还没放弃，那么你可以在完成后，把文章链接贴到评论里，或者直接投稿《驳《教轮子哥学一点点C++ (1)》》</p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++ (1) 答疑",
            "excerpt_title": "",
            "excerpt": "有很多人对<a href=\"https://zhuanlan.zhihu.com/p/24535431\" data-editable=\"true\" data-title=\"知乎专栏\" class=\"\"> 教轮子哥学一点点C++ (1)</a> 提出疑问，表示不理解这篇文章，认为这么简单达不到劝退的效果。真的是这样的吗？我说过，这个系列是要用轮子哥的方式来劝退C++。什么是轮子哥的方式？那就是造轮子啊。假如你之前没有造过类似的轮子，看完之后也没想自…"
        },
        {
            "type": "article",
            "updated": 1482561975,
            "id": 24541264,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1482561390,
            "url": "",
            "content": "<p>本期就讲一点点关于 allocator 类型的问题</p><p>C++ STL里的Allocator类型完全是不讲道理的。你传给container的allocator并不是container真正使用allocator。比如你传进去的是allocator1，而container实际使用的是allocator2</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>Allocator&lt;T&gt; allocator1(...);\nAllocator&lt;Node&lt;T&gt;&gt; allocator2(allocator1);\n</code></pre></div><p>使用者会对此感到困惑，而对于Allocator的作者来说，这是个灾难。假如你想在固定一片内存区域内分配空间，这就意味这 allocator2 和 allocator1 指向的是同一片内存区域，也就是 Allocator 必须在同一片区域内支持多种不同类型的分配，因为至少你是不好阻止别人同时使用 allocator1 和 allocator2 的。这个问题实际上就是 Allocator 类型没搞对造成的。一个 allocator 就该是一个 container 真正独占的。你想共用可以通过共用同一个参数来实现。</p><p>所以更合理的写法是类似下面这样的。</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">Node</span> <span class=\"p\">{</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span><span class=\"o\">&gt;</span> <span class=\"k\">typename</span> <span class=\"n\">Allocator</span><span class=\"o\">&gt;</span>\n<span class=\"n\">List</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"n\">Allocator</span><span class=\"o\">&lt;</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;&gt;&amp;&amp;</span>\n<span class=\"n\">create_list_with_allocator</span><span class=\"p\">(</span><span class=\"n\">Allocator</span><span class=\"o\">&lt;</span><span class=\"n\">Node</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"o\">&gt;&gt;&amp;&amp;</span> <span class=\"n\">allocator</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"p\">...</span>\n<span class=\"p\">}</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">SimpleAllocator</span> <span class=\"p\">{</span>\n  <span class=\"n\">SimpleAllocator</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">int</span>\n<span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"n\">create_list_with_allocator</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">SimpleAllocator</span><span class=\"o\">&gt;</span><span class=\"p\">({</span><span class=\"nl\">id</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">});</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>这样我们正确表示了Allocator的类型，而且使用者是不需要知道 Node 的。</p><p>然而这并不足以完全解决问题。假如 Allocator需要多个模板参数呢？</p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"k\">typename</span><span class=\"o\">&gt;</span>\n<span class=\"k\">struct</span> <span class=\"n\">AdvancedAllocator</span> <span class=\"p\">{</span>\n<span class=\"p\">};</span>\n\n<span class=\"k\">template</span><span class=\"o\">&lt;</span><span class=\"k\">typename</span> <span class=\"n\">T</span><span class=\"o\">&gt;</span>\n<span class=\"k\">using</span> <span class=\"n\">MyAllocator</span> <span class=\"o\">=</span> <span class=\"n\">AdvancedAllocator</span><span class=\"o\">&lt;</span><span class=\"n\">T</span><span class=\"p\">,</span> <span class=\"kt\">int</span><span class=\"o\">&gt;</span><span class=\"p\">;</span>\n\n<span class=\"kt\">int</span>\n<span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"n\">create_list_with_allocator</span><span class=\"o\">&lt;</span><span class=\"kt\">int</span><span class=\"p\">,</span> <span class=\"n\">MyAllocator</span><span class=\"o\">&gt;</span><span class=\"p\">({});</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>要注意到MyAllocator的声明是不能放到 main 里面的。很多年以前，有很多人吐槽Ada那个别名写起来很啰嗦。但是经过这么多年发展以后，C++的别名写起来哪里不啰嗦了。而现在，信出现的语言，比如Rust，支持Trait和Type Inference，这样的用法是不需要别名的，差不多像这样就可以了</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>List::&lt;int, _&gt;::new_with_allocator(Allocator::new(...));\n</code></pre></div><p>好了，这一期就到这里了，也就是简单用了一下type deduction和rvalue reference。</p><p>-----------------------------------------<br></p><p>这同样也可以运用到轮子哥在<a href=\"https://zhuanlan.zhihu.com/p/24365844\" class=\"internal\">随手干点什么都能发现开源界可以婊的东西</a>提到的例子。比较理想的，我们应该写的像下面这样，异常要产生也是在进入emplace之前产生的 。 而现在因为STL语义的问题，我们是办不到的。这也导致了container有intrusive和non-intrusive的区分。container的作者还要去管里面的元素是怎么建出来，这当然容易出错了，而且 emplace 那行也很费解。<br></p><div class=\"highlight\"><pre><code class=\"language-cpp\"><span></span><span class=\"cp\">#include</span> <span class=\"cpf\">&lt;stdio.h&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;iterator&gt;</span><span class=\"cp\"></span>\n<span class=\"cp\">#include</span> <span class=\"cpf\">&lt;vector&gt;</span><span class=\"cp\"></span>\n\n<span class=\"k\">struct</span> <span class=\"n\">Wheel</span> <span class=\"p\">{</span>\n  <span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"p\">;</span>\n\n  <span class=\"n\">Wheel</span><span class=\"p\">(</span><span class=\"kt\">int</span> <span class=\"n\">id</span><span class=\"p\">,</span> <span class=\"kt\">bool</span> <span class=\"n\">to_throw</span> <span class=\"o\">=</span> <span class=\"nb\">false</span><span class=\"p\">)</span> <span class=\"o\">:</span> <span class=\"n\">id</span><span class=\"p\">(</span><span class=\"n\">id</span><span class=\"p\">)</span> <span class=\"p\">{</span>\n    <span class=\"k\">if</span><span class=\"p\">(</span><span class=\"n\">to_throw</span><span class=\"p\">)</span>\n       <span class=\"k\">throw</span> <span class=\"mi\">1</span><span class=\"p\">;</span>\n  <span class=\"p\">}</span>\n<span class=\"p\">};</span>\n\n<span class=\"kt\">int</span>\n<span class=\"nf\">main</span><span class=\"p\">()</span> <span class=\"p\">{</span>\n  <span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">vector</span><span class=\"o\">&lt;</span><span class=\"n\">Wheel</span><span class=\"o\">&gt;</span> <span class=\"n\">wheels</span><span class=\"p\">;</span>\n  <span class=\"n\">wheels</span><span class=\"p\">.</span><span class=\"n\">reserve</span><span class=\"p\">(</span><span class=\"mi\">4</span><span class=\"p\">);</span>\n\n  <span class=\"n\">wheels</span><span class=\"p\">.</span><span class=\"n\">emplace_back</span><span class=\"p\">({</span><span class=\"nl\">id</span><span class=\"p\">:</span> <span class=\"mi\">1</span><span class=\"p\">});</span>\n  <span class=\"n\">wheels</span><span class=\"p\">.</span><span class=\"n\">emplace_back</span><span class=\"p\">({</span><span class=\"nl\">id</span><span class=\"p\">:</span> <span class=\"mi\">2</span><span class=\"p\">});</span>\n  <span class=\"n\">wheels</span><span class=\"p\">.</span><span class=\"n\">emplace_back</span><span class=\"p\">({</span><span class=\"nl\">id</span><span class=\"p\">:</span> <span class=\"mi\">3</span><span class=\"p\">});</span>\n\n  <span class=\"k\">try</span> <span class=\"p\">{</span>\n    <span class=\"n\">wheels</span><span class=\"p\">.</span><span class=\"n\">emplace</span><span class=\"p\">(</span><span class=\"o\">::</span><span class=\"n\">std</span><span class=\"o\">::</span><span class=\"n\">begin</span><span class=\"p\">(</span><span class=\"n\">wheels</span><span class=\"p\">)</span> <span class=\"o\">+</span> <span class=\"mi\">2</span><span class=\"p\">,</span> <span class=\"p\">{</span><span class=\"nl\">id</span><span class=\"p\">:</span> <span class=\"mi\">4</span><span class=\"p\">,</span> <span class=\"nl\">to_throw</span><span class=\"p\">:</span> <span class=\"nb\">true</span><span class=\"p\">});</span>\n  <span class=\"p\">}</span> <span class=\"k\">catch</span> <span class=\"p\">(...)</span> <span class=\"p\">{</span>\n  <span class=\"p\">}</span>\n\n  <span class=\"k\">for</span> <span class=\"p\">(</span><span class=\"k\">auto</span><span class=\"o\">&amp;</span> <span class=\"nl\">wheel</span> <span class=\"p\">:</span> <span class=\"n\">wheels</span><span class=\"p\">)</span>\n    <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"%d \"</span><span class=\"p\">,</span> <span class=\"n\">wheel</span><span class=\"p\">.</span><span class=\"n\">id</span><span class=\"p\">);</span>\n\n  <span class=\"n\">printf</span><span class=\"p\">(</span><span class=\"s\">\"</span><span class=\"se\">\\n</span><span class=\"s\">\"</span><span class=\"p\">);</span>\n<span class=\"p\">}</span>\n</code></pre></div><p>轮子哥不告诉大家这是应该避免的写法，只顾着把别人的Bug批判一番，也是很棒的。</p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++ (2)",
            "excerpt_title": "",
            "excerpt": "本期就讲一点点关于 allocator 类型的问题C++ STL里的Allocator类型完全是不讲道理的。你传给container的allocator并不是container真正使用allocator。比如你传进去的是allocator1，而container实际使用的是allocator2Allocator&lt;T&gt; allocator1(...);\nAlloca…"
        },
        {
            "type": "article",
            "updated": 1483441744,
            "id": 24540655,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1482551389,
            "url": "",
            "content": "<p>同主题的前一篇被举报了。所以重新发一遍。</p><p>轮子哥既不会(现代)C++，C++也不支持什么面向对象。轮子哥却要强行开课</p><blockquote><p>基于现代的C++构建，教你以面向对象思想编写优雅而健壮的代码 </p></blockquote><p>你也可能会发现轮子哥的一些写法既不优雅也不健壮。这也就算了，轮子哥的课程却在那里宣传帮你 “ 克服“从入门到放弃” ”。所以，我们要开一个系列把轮子哥批判一番。为什么只能是一点点C++，因为没有人可以学会C++，哪怕只是一点点C++，里面也充斥着奇技淫巧。早一天放弃C++，早一天解脱。</p><p>我们的目标是达成<a href=\"https://zhuanlan.zhihu.com/p/24328534\" class=\"internal\">为什么不再想碰 C++</a> 题图里的效果，我们的口号是劝退一人胜造<a href=\"https://www.zhihu.com/question/24078259\" class=\"internal\">轮子哥三大浪漫</a>。<br></p><p>以下是本系列文章列表，<b>欢迎踊跃投稿 </b></p><p><a href=\"https://zhuanlan.zhihu.com/p/24535431\" class=\"internal\">教轮子哥学一点点C++ (1)</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/24547564\" class=\"internal\">教轮子哥学一点点C++ (1) 答疑</a><br></p><p><a href=\"https://zhuanlan.zhihu.com/p/24541264\" class=\"internal\">教轮子哥学一点点C++ (2)</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/24553653\" class=\"internal\">教轮子哥学一点点C++ (3)</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/24640224\" class=\"internal\">教轮子哥学一点点C++ (4)</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/24643171\" class=\"internal\">教轮子哥学一点点C++ (5)</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/24693000\" class=\"internal\">教轮子哥学一点点C++ (6)</a></p><p><a href=\"https://zhuanlan.zhihu.com/p/24694834\" class=\"internal\">教轮子哥学一点点C++ (7)</a></p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++",
            "excerpt_title": "",
            "excerpt": "同主题的前一篇被举报了。所以重新发一遍。轮子哥既不会(现代)C++，C++也不支持什么面向对象。轮子哥却要强行开课基于现代的C++构建，教你以面向对象思想编写优雅而健壮的代码 你也可能会发现轮子哥的一些写法既不优雅也不健壮。这也就算了，轮子哥的课程却…"
        },
        {
            "type": "article",
            "updated": 1482553451,
            "id": 24535431,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1482501960,
            "url": "",
            "content": "<p>只能讲一点点，因为C++这么复杂，大家最多就只能会一点点。只要会了一点点，你就知道应该果断放弃C++。假如坚持不放弃的，那一定是一点都不会的。</p><p>本期就先来最简单的，就讲一点点<a href=\"http://link.zhihu.com/?target=https%3A//github.com/philsquared/Catch\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Catch<i class=\"icon-external\"></i></a>  的SECTION 的原理。</p><p>大家都知道，C/C++函数里的static变量，只会在这个函数第一次运行时初始化，之后就一直存在在那里了。</p><p>大家都知道，在 if 语句的条件里，声明一个普通变量，他是要等到 if 语句的body执行完才会死的。</p><p>所以经过简化再简化，Catch的一个 SECTION 展开来大概长这样<br></p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>static Section section1;\nif (Condition condition1 = section1) {\n}\n</code></pre></div><p>而一个 TESTCASE 就是一个函数。每次运行有一个 State</p><p>State, Section, 都有一个标记记录是否运行结束</p><p>每当执行到  condition1 = section1 时，condition1 首先会判断， state有没有结束，假如已经结束，那么 把 condition1 转换成 bool 会得到 false ，也就是不会运行 if 语句的 body 。这样就保证了，多个同级 SECTION ，运行一次 TESTCASE 最多只有一个可以运行。</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span> SECTION(\"a\") {\n }\n\n SECTION(\"b\") {\n }\n\n SECTION(\"c\") {\n }\n</code></pre></div><p>假如 state 没有结束，那么 condition1 会判断 section1 有没有结束，假如已经结束，说明 if 语句 body 里所有测试都运行完了，不需要再运行了。假如 section1 没有结束，那么就 标记进入了 section1，运行测试。<br></p><p>每当执行到 condition1 的 destructor 时，假如当前 没有进入section1 ，那么就啥也不用做</p><p>假如标记 进入了section1，那么就取消标记。同时，判断 state 有没有结束，假如 state 已经结束了，说明有一个内层的 SECTION 运行结束了，那这样就可以了。假如 state 没有结束，说明 section1 的所有测试都运行完了，那么就标记 section1 结束，同时标记 state 结束。</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>SECTION(\"a\") {\n  SECTION(\"b\") {\n  }\n\n  SECTION(\"c\") {\n  }\n}\n</code></pre></div><p>同时，我们可以看出，假如所有 section 都运行完了，我们再去运行一次 TESTCASE ，state是不会被标记为结束的。因此，我们可以以此来判断整个 TESTCASE 有没有运行完。</p><p>好了，这一期就到这里了。</p><p>大家不要告诉轮子哥，TestCase只用一个类就好，在constructor那里，把自己插入到一个双向链表里的。双向链表的头尾都是TestCase的static成员。这样就不需要在main函数之前运行了。</p><p>轮子哥把约等于 __attribute__((constructor)) 的功能称为单元测试框架，到现在还在用那个，也是厉害，参考<a href=\"https://www.zhihu.com/question/22608939/answer/21963056\" class=\"internal\">什么时候应该使用宏定义？ - vczh 的回答 - 知乎</a></p>",
            "image_url": "",
            "title": "教轮子哥学一点点C++ (1)",
            "excerpt_title": "",
            "excerpt": "只能讲一点点，因为C++这么复杂，大家最多就只能会一点点。只要会了一点点，你就知道应该果断放弃C++。假如坚持不放弃的，那一定是一点都不会的。本期就先来最简单的，就讲一点点<a href=\"http://link.zhihu.com/?target=https%3A//github.com/philsquared/Catch\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">Catch<i class=\"icon-external\"></i></a> 的SECTION 的原理。大家都知道，C/C++函数里的static变量，只会在这个…"
        },
        {
            "type": "article",
            "updated": 1481770296,
            "id": 24379057,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1481770236,
            "url": "",
            "content": "<p>ECMAScript社区在为ES6的到来欢呼雀跃。他们没注意到也不会注意到JavaScript已经死了。一直以来ECMAScript程序员和JavaScript程序员是很容易区分的，只要看他能不能写出只能在Firefox里运行的脚本。比如，一个ECMAScript程序员会写自己的工具来支持yield，而JavaScript程序员就直接用yield了。而现在的Firefox里，script的type设置成 application/javascript;version=1.8 和不加version不会有任何区别。也就是JavaScript已经死了，我们再也找不出JavaScript程序员了。</p>",
            "image_url": "",
            "title": "JavaScript已死",
            "excerpt_title": "",
            "excerpt": "ECMAScript社区在为ES6的到来欢呼雀跃。他们没注意到也不会注意到JavaScript已经死了。一直以来ECMAScript程序员和JavaScript程序员是很容易区分的，只要看他能不能写出只能在Firefox里运行的脚本。比如，一个ECMAScript程序员会写自己的工具来支持yield，…"
        },
        {
            "type": "article",
            "updated": 1481706907,
            "id": 24368364,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1481706908,
            "url": "",
            "content": "<p>看了好多网页版代码编辑器还有在网页上显示代码高亮的工具，发现这个行号显示都搞的特别高级。感觉那样很不好，抄袭起来太麻烦。查阅CSS文档之后，发现还是很容易用CSS实现的，效果也基本令人满意。</p><p>CSS代码如下</p><div class=\"highlight\"><pre><code class=\"language-css\"><span></span><span class=\"k\">@counter-style</span> <span class=\"nt\">lno</span> <span class=\"p\">{</span>\n    <span class=\"nt\">system</span><span class=\"o\">:</span> <span class=\"nt\">extends</span> <span class=\"nt\">decimal</span><span class=\"o\">;</span>\n    <span class=\"nt\">pad</span><span class=\"o\">:</span> <span class=\"nt\">4</span> <span class=\"s2\">\" \"</span><span class=\"o\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nt\">pre</span> <span class=\"p\">{</span>\n    <span class=\"nb\">margin</span><span class=\"o\">:</span> <span class=\"m\">0</span> <span class=\"m\">0</span> <span class=\"m\">0</span> <span class=\"m\">5</span><span class=\"n\">ch</span><span class=\"p\">;</span>\n    <span class=\"nb\">counter-reset</span><span class=\"o\">:</span> <span class=\"n\">line</span><span class=\"p\">;</span>\n    <span class=\"nb\">width</span><span class=\"o\">:</span> <span class=\"m\">4</span><span class=\"n\">ch</span><span class=\"p\">;</span>\n    <span class=\"nb\">white-space</span><span class=\"o\">:</span> <span class=\"n\">pre</span><span class=\"o\">-</span><span class=\"n\">wrap</span><span class=\"p\">;</span>\n    <span class=\"n\">word</span><span class=\"o\">-</span><span class=\"n\">break</span><span class=\"o\">:</span> <span class=\"n\">break</span><span class=\"o\">-</span><span class=\"n\">all</span><span class=\"p\">;</span>\n    <span class=\"nb\">outline</span><span class=\"o\">:</span> <span class=\"m\">1px</span> <span class=\"nb\">solid</span> <span class=\"nb\">red</span><span class=\"p\">;</span>\n    <span class=\"nb\">border-left</span><span class=\"o\">:</span> <span class=\"m\">1px</span> <span class=\"nb\">solid</span> <span class=\"nb\">blue</span><span class=\"p\">;</span>\n    <span class=\"nb\">background-color</span><span class=\"o\">:</span> <span class=\"m\">#EEE</span><span class=\"p\">;</span>\n    <span class=\"nb\">padding</span><span class=\"o\">:</span> <span class=\"m\">0</span> <span class=\"m\">1</span><span class=\"n\">ch</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nt\">pre</span> <span class=\"nt\">span</span><span class=\"nc\">.line</span> <span class=\"p\">{</span>\n    <span class=\"nb\">counter-increment</span><span class=\"o\">:</span> <span class=\"n\">line</span><span class=\"p\">;</span>\n    <span class=\"n\">box</span><span class=\"o\">-</span><span class=\"n\">decoration</span><span class=\"o\">-</span><span class=\"n\">break</span><span class=\"o\">:</span> <span class=\"n\">clone</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n\n<span class=\"nt\">pre</span> <span class=\"nt\">span</span><span class=\"nc\">.line</span><span class=\"o\">:</span><span class=\"nd\">:before</span> <span class=\"p\">{</span>\n    <span class=\"nb\">content</span><span class=\"o\">:</span> <span class=\"n\">counter</span><span class=\"p\">(</span><span class=\"n\">line</span><span class=\"o\">,</span> <span class=\"n\">lno</span><span class=\"p\">);</span>\n    <span class=\"nb\">margin</span><span class=\"o\">:</span> <span class=\"m\">0</span> <span class=\"m\">2</span><span class=\"n\">ch</span> <span class=\"m\">0</span> <span class=\"m\">-6</span><span class=\"n\">ch</span><span class=\"p\">;</span>\n<span class=\"p\">}</span>\n</code></pre></div><p> 举个例子</p><div class=\"highlight\"><pre><code class=\"language-html\"><span></span><span class=\"p\">&lt;</span><span class=\"nt\">pre</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>aa aaa aaa<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;</span><span class=\"nt\">span</span> <span class=\"na\">class</span><span class=\"o\">=</span><span class=\"s\">\"line\"</span><span class=\"p\">&gt;</span>a<span class=\"p\">&lt;/</span><span class=\"nt\">span</span><span class=\"p\">&gt;</span>\n<span class=\"p\">&lt;/</span><span class=\"nt\">pre</span><span class=\"p\">&gt;</span>\n</code></pre></div><p> 没想到如此简单</p>",
            "image_url": "",
            "title": "用CSS画行号",
            "excerpt_title": "",
            "excerpt": "看了好多网页版代码编辑器还有在网页上显示代码高亮的工具，发现这个行号显示都搞的特别高级。感觉那样很不好，抄袭起来太麻烦。查阅CSS文档之后，发现还是很容易用CSS实现的，效果也基本令人满意。CSS代码如下@counter-style lno {\n system: extends decim…"
        },
        {
            "type": "article",
            "updated": 1480042059,
            "id": 23881270,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1479878332,
            "url": "",
            "content": "<p>首先曾老师表示了支持</p><p>---------------------------------------</p><p>比如像轮子哥对李某的课程提出了质疑，认为36万一年才合理。也有其他人提出大学4年学费也不用6万。他们的说法本身就是问题。你就想一想高铁时间短，为什么票价还比普通列车高呢？相同的内容，两个月的学费比四年的学费贵是没什么问题。而一年的学费比两个月贵好几倍，那是抢劫。</p><p>真正的问题就像一些回答指出的那样，李某自称英语名师，然而在各种课程里出现的最最常见的一个单词，他却大大方方的错了。这不得不让人怀疑他实际内容的质量了。</p><p>假如真的出现了一个很好的课程，2个月6万，你问我是否值得报名。我肯定会告诉你不值得。很简单，假如你自学需要4个月才能学会，而参加那个课程只要2个月，价格是6万，那就意味着，你一个月能赚不到3万肯定是亏的。你的时间并没有那么值钱。</p><p>野鸡培训生意兴隆，只能说明这方面确实有很大的需求。那么正规学校又在干什么呢？比如曾老师提到过某三本大学的教授在猪网开了一个公开课，教大家数据结构，结果有人跟着他的课程没学会，他却在那里指责学生智商低，还说什么实在学不会的话可以去参加他办的野鸡考试，这样一样可以对找工作有帮助的。</p><p>而很多自称程序员的人心态是有问题的，说的好像自己花了很多时间才学会的东西，别人必须也花差不多时间才可能学会。这样我们不就永远都不会进步了。更有甚者，听说了几个名词就觉得自己高人一等了，脱离了初学者的层次了。连递归都能拿出来说。要知道数数就要用到递归了。甚至还有人产生了普通人不该也不可能学会写程序的幻觉。</p><p>他们同样也会去鄙视一些夸夸其谈的产品经理，根本就不懂计算机，在那里大谈用户体验。却没有意识到，这个问题归根结底是他们自己造成的。Because as a wise young man once said, Life's too short。有了计算机，我们明明可以一次把几十个东西处理完的，很多软件却非要我们一个个点过来，这是在浪费别人的时间，这是犯罪。</p><p>所以我们应该让写程序变得更容易，让学写程序变得更容易，这样人人都可以学会。到时候，大家都会认为没有API就别吹用户体验，这样我们才能算是进入了计算机时代。</p><p>你想说你什么都不会，啥也做不了，对此无能为力。不是的，你可以的。我们的口号是If you can't do, teach。我听曾老师提起过，费曼曾经说过，假如你不能给 X岁小朋友讲明白，那就说明你自己就没搞明白的。我试过了，效果惊人，每次小朋友就问了不到十个为什么就把我问倒了，这样很快就帮助我找出了我没搞明白的地方。正如，<a href=\"https://www.zhihu.com/question/52338974/answer/130092827\" class=\"internal\"><span class=\"invisible\">https://www.</span><span class=\"visible\">zhihu.com/question/5233</span><span class=\"invisible\">8974/answer/130092827</span><span class=\"ellipsis\"></span></a> 倡导的那样，什么都不知道才是最好的。 </p><p>现在很多计算机方面的教材，资料什么的很多确实搞的过于复杂了。Philip Wadler就吐槽过我们现在已经搞的过于复杂了，再复杂下去个个都会像Haskell那样变得avoid success at all costs了。比如什么二叉树，用ML写，一眼就看明白了，很多人还在坚持用C讲，听的人全糊涂了，还觉得自己讲的挺好的。</p><p>于是，前段时间在 <a href=\"https://www.zhihu.com/people/141d3b5a28d4d435f500c4d9a1c94d2b\" data-hash=\"141d3b5a28d4d435f500c4d9a1c94d2b\" class=\"member_mention\" data-editable=\"true\" data-title=\"@如月更纱\" data-hovercard=\"p$b$141d3b5a28d4d435f500c4d9a1c94d2b\">@如月更纱</a> 的带领下 ，有了<a href=\"https://link.zhihu.com/?target=https%3A//fast-track.github.io/\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\"> https://fast-track.github.io/<i class=\"icon-external\"></i></a> (没错就是写伪书)，不追求系统，只追求能帮助尽快掌握某个知识点，不废话，不瞎扯什么思想。原理部分主要就是在能跑通的前提下，把无关的东西都去掉，尽可能的短。实战部分要求基本功能都有，并且可以实际使用，但是不追求跑分，也不追求功能全面。</p><p>你有啥想法，就直接开个Issue。没问题，就会把这个Issue添加到Project里，并给你这个单独开个仓库，并把管理权限给你。当然，你也可以选择自己啥都写好了，再发个Pull Request要求加入。假如你不知道咋写，你也可以写想要什么样的内容，说不定有人想不好写啥，看到了，就来写了。</p>在编程口诀出现之前的黑暗日子里，就靠你们了。我们的口号是，If you can't do, teach。",
            "image_url": "",
            "title": "If you can't do, teach.",
            "excerpt_title": "",
            "excerpt": "首先曾老师表示了支持---------------------------------------比如像轮子哥对李某的课程提出了质疑，认为36万一年才合理。也有其他人提出大学4年学费也不用6万。他们的说法本身就是问题。你就想一想高铁时间短，为什么票价还比普通列车高呢？相同的内容，…"
        },
        {
            "type": "article",
            "updated": 1479787026,
            "id": 23853171,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1479786607,
            "url": "",
            "content": "<p><a href=\"https://zhuanlan.zhihu.com/kls-software-arch-world\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/kls-</span><span class=\"invisible\">software-arch-world</span><span class=\"ellipsis\"></span></a></p><p>里面错误实在太多，曾老师说了不堪卒读啊。竟然能有上千关注啊</p><p>之前只看过一篇 <a href=\"https://zhuanlan.zhihu.com/p/22386524\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/p/22</span><span class=\"invisible\">386524</span><span class=\"ellipsis\"></span></a> 当场就吓尿了，真没见过错的这么离谱的。流水线破坏前两个例子全是错的</p><p>第一个例子</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>r1=r2+r3\nr1=r1+1\nr4=r4+2\n</code></pre></div><p>在简单的流水线里， 这个第二条指令更可能的结果是不会产生任何STALL。假设我们只有一个计算加法的单元，且一个周期只能计算一个加法，那么等计算第二条指令的加法的周期开始时，第一条指令的加法的结果已经出来了，我们只需要加一个简单的判断，假如这个寄存器是刚刚运行的指令写入的，那么直接从运算结果那里读取寄存器的数值。这样流水线不会有任何停顿的。当然了，复杂的流水线我们是不能这么轻易下结论的。</p><p>你一定要说这个必然导致流水线停顿那当然是错的了。</p><p>第二个例子</p><p>jmp跳转到一个固定的地址，哪来的指令预测失效。</p><p>这对于早期的MIPS之类的指令，倒是一个pipeline STALL的例子。假如没有delay slot，遇到jmp指令，就会一直往流水线插入空指令，直到jmp指令执行，修改了pc。</p><p>错了就错了。这也没啥。真正让人惊呆的是，<a href=\"https://zhuanlan.zhihu.com/p/23788985\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/p/23</span><span class=\"invisible\">788985</span><span class=\"ellipsis\"></span></a> 里，他竟然提出</p><blockquote><p>作者没有足够的编码经验。在没有把代码写出来前，他完全无法对代码进行预判 ...... 他需要写一小段，编译一下，看看是不是可以工作的，然后在写一小段，再看看能否工作，说不定还要跟踪一下流程。这种人，你让他写高层设计实在是难为他了。这种就不要想什么高层设计了，自己骗自己，就拿着编码来做练习，等着跌上几交，教够学费了再说吧。</p></blockquote><p>写一小段就检查一下能否工作是非常必要的。我们要避免的就是只凭经验来做设计。人的记忆力是非常有限的，我们需要去验证我们在设计中作出的任何假设，论断。这就需要写一些简单的例子来验证一下。就像他对CPU流水线的错误理解，用VHDL写个非常简单的流水线，就能知道是无法得出那些结论的。</p>",
            "image_url": "",
            "title": "惊呆了，那个软件架构设计专栏还在更新啊",
            "excerpt_title": "",
            "excerpt": "<a href=\"https://zhuanlan.zhihu.com/kls-software-arch-world\" class=\"\">https://zhuanlan.zhihu.com/kls-software-arch-world</a>里面错误实在太多，曾老师说了不堪卒读啊。竟然能有上千关注啊之前只看过一篇 <a href=\"https://zhuanlan.zhihu.com/p/22386524\">https://zhuanlan.zhihu.com/p/22386524</a> 当场就吓尿了，真没见过错的这么离谱的。流水线破坏前两个例子全是错的第一个例子r1=r2+r3\nr1=r1+1\nr4=r4+2\n在简单的流水线里， 这个…"
        },
        {
            "type": "article",
            "updated": 1479782305,
            "id": 23844488,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1479741424,
            "url": "",
            "content": "<p><a href=\"https://zhuanlan.zhihu.com/prattle\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/prat</span><span class=\"invisible\">tle</span><span class=\"ellipsis\"></span></a></p><p>里面错误实在太多，曾老师说了不堪卒读啊。竟然能有上万关注啊</p><p>之前只看过一篇 <a href=\"https://zhuanlan.zhihu.com/p/20082260\" class=\"internal\"><span class=\"invisible\">https://</span><span class=\"visible\">zhuanlan.zhihu.com/p/20</span><span class=\"invisible\">082260</span><span class=\"ellipsis\"></span></a>，当场就吓尿了，Juniper的<b>Senior Staff Engineer</b>竟然大大方方的把data plane和control plane搞反了</p><blockquote><p>按照teamspark的功能，chat和notification是data plane，需要最高的效率，使用websocket承载。</p><br><p>其他信息流都是control plane，可以走慢速通道，用HTTP承载。比如成员A在任务B下上传一个文件，上传文件的动作使用HTTP API；\"A上传了一个文件：xxx\" 这个消息，用websocket传输。这样可以保证websocket上的通道上总是小数据，保持畅通。</p></blockquote><p>更别说</p><blockquote><p>题外话：whatsapp一开始把宝押在ejabber上，是因为其创始人在此的累计：嫌BEAM性能不好，自己patch，更别提ejabber了 </p></blockquote><p>这个根本就是他自己瞎编的谣言。所有WhatsApp自己公开的资料说的大约都是他们当时对Erlang并不是很熟，只是觉得Ejabberd改起来快就先用着了，根本就不在乎BEAM运行速度快不快，等他们第一次碰到问题时，同时在线人数都已经接近两百万了。我看Erlang不流行，也有他一份功劳。别的错误就不一一指出了。 </p><p>最近这篇<a href=\"https://zhuanlan.zhihu.com/p/23827375\" class=\"internal\"> https://zhuanlan.zhihu.com/p/23827375</a> 简直不知道说啥好了，竟然是在吹嘘EAV anti-pattern，举的例子还是错的。他举的例子，特别是他特别强调的Rails，里面的Active Record用起来是很别扭的，动不动就要自己去写SQL来完成一个查询，尽管方式不一样，用起来的感觉更接近他推荐的方法。像他说的那样一上来就完全拆开是不合理的，很多时候就相当于需要自己去处理JOIN和transaction了，和关系数据库背道而驰。</p>",
            "image_url": "",
            "title": "惊呆了，那个迷思专栏还在更新啊",
            "excerpt_title": "",
            "excerpt": "<a href=\"https://zhuanlan.zhihu.com/prattle\">https://zhuanlan.zhihu.com/prattle</a>里面错误实在太多，曾老师说了不堪卒读啊。竟然能有上万关注啊之前只看过一篇 <a href=\"https://zhuanlan.zhihu.com/p/20082260\" class=\"\">https://zhuanlan.zhihu.com/p/20082260</a>，当场就吓尿了，Juniper的<b>Senior Staff Engineer</b>竟然大大方方的把data plane和control plane搞反了按照teamspark的功能，chat和notif…"
        }
    ]
}