{
    "paging": {
        "next": "https://www.zhihu.com/api/v4/members/bhuztez/articles?include=data%5B%2A%5D.content&limit=20&offset=120",
        "previous": "https://www.zhihu.com/api/v4/members/bhuztez/articles?include=data%5B%2A%5D.content&limit=20&offset=80",
        "is_end": true,
        "totals": 106,
        "is_start": false
    },
    "data": [
        {
            "type": "article",
            "updated": 1459343406,
            "id": 19930232,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1420601560,
            "title": "为什么21天能学通Erlang？",
            "content": "<img data-rawheight=\"788\" data-rawwidth=\"1024\" src=\"https://pic4.zhimg.com/bd4c9b5f3d8f42e7ca670e1ab9c8fe0b_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic4.zhimg.com/bd4c9b5f3d8f42e7ca670e1ab9c8fe0b_r.jpg\"><img data-rawheight=\"788\" data-rawwidth=\"1024\" src=\"https://pic3.zhimg.com/3b515611f8884ffe148ec97ed8ba7b22_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic3.zhimg.com/3b515611f8884ffe148ec97ed8ba7b22_r.jpg\"><img data-rawheight=\"788\" data-rawwidth=\"1024\" src=\"https://pic4.zhimg.com/c1956f02e168ac564d4f9691781d978b_b.jpg\" class=\"origin_image zh-lightbox-thumb\" width=\"1024\" data-original=\"https://pic4.zhimg.com/c1956f02e168ac564d4f9691781d978b_r.jpg\"><p>图来自<a class=\" external\" href=\"http://link.zhihu.com/?target=http%3A//pugs.blogs.com/talks/dls06-pugs.pdf\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">pugs.blogs.com/talks/dl</span><span class=\"invisible\">s06-pugs.pdf</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a></p>",
            "image_url": "",
            "url": "",
            "excerpt_title": "",
            "excerpt": "图来自<a class=\" external\" href=\"http://link.zhihu.com/?target=http%3A//pugs.blogs.com/talks/dls06-pugs.pdf\" target=\"_blank\" rel=\"nofollow noreferrer\"><span class=\"invisible\">http://</span><span class=\"visible\">pugs.blogs.com/talks/dl</span><span class=\"invisible\">s06-pugs.pdf</span><span class=\"ellipsis\"></span><i class=\"icon-external\"></i></a>"
        },
        {
            "type": "article",
            "updated": 1459343344,
            "id": 19923539,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1419777029,
            "title": "21天学通Erlang从写解释器开始",
            "content": "<p>前几天有几个人一致向我抱怨说这个21天学通Erlang是不是太偏理论了。我不认同这种观点。</p><p>没人会否定Erlang是一门实用的语言。Erlang不需要一本Practical Common Lisp/Real World Haskell/Real World OCaml来标榜自己也是实用的。Erlang的成名不就是因为在上面开发出了9个9的产品啊。即便是国内，也有很多公司在用RabbitMQ，CouchBase什么的。可是，即便能用Erlang方便开发出高可用的服务，还是被认为这主要是因为BEAM，OTP，以及容错的思想，和Erlang语言一点关系都没有。Erlang可能遇到了一个别的语言都没遇到过的麻烦，越强调Erlang之强大，Erlang就越难以被采用。你看某人的PySonar的粉丝都比HiPE多，即便PySonar离Practical还远着呢，即便PySonar比HiPE晚出现了可能都不止5年，即便有些PySonar作者在slides里提到的问题在Erlang/HiPE里并不存在，还不是被很多人当作原创的新东西看待，还不是被各种膜拜。要推广Erlang要从新手抓起。</p><p>当然了，这不代表21天学通Erlang里不该写一些实际程序的例子。但是，也别一上来就讲非常实际的例子啊。你们总不能因为Erlang如此实用，在第一章就得开始写实际的东西吧。21天学通Erlang是一本用来入门的书啊。大哥们。</p><p>Erlang是一门非常适合用来入门的语言，Erlang语言本身很简单。而我们只需要用其中模式匹配和函数的部分对于写一些简单的解释器来说已经足够方便了。用Erlang，就不需要像SICP那样，一开始先花三章让你学会用scheme。SICP的思路是，等你学会用scheme里，你就可以开始看后面两章来理解scheme的语义，你理解了scheme的语义，你就能学会scheme了。你看这就是个鸡蛋问题嘛。用Erlang，就不用像SICP那样兜个大圈子。一开始我们只介绍Erlang里的模式匹配和函数的概念，接着你就可以只用这两个概念来写一个解释器，这个解释器足以解释和Erlang中类似的模式匹配和函数。这些已经足够你验证自己是否理解模式匹配和函数了。而不是像看什么C++ Primer之类的书一样知其然不知其所以然，感觉自己好像学会了一门语言，但里面随便挑点功能出来，连个解释器都写不出来。<br></p><p>Erlang不止是这些。我们还要把解释器改成回溯和合一，这样就是一个Prolog了。Erlang的原型是用Prolog写的，我希望这个Prolog足够解释和Erlang原型功能相同的Prolog程序。另外Parser是一个特殊的解释器，Prolog就有DCG嘛。所以到这里你已经能从源代码直接解释一部分Erlang程序了。后面这部分我想我已经重复了好多遍了，就是把Prolog的回溯改成tabling就变成了Datalog。Datalog对应的Parser，就是Earley了，Earley一路弱化最后成了正则表达式。至此，你自己就可以写一个简单的lex/yacc工具了，而不用像SICP那样整天躲在括号后面。</p><p>到这里你肯定还是很困惑，你不能确定自己写对了没，你也不该相信我，毕竟我说的都是错的。既然会写解释器了，那就根据Curry-Howard Correspondence把解释器改改，改成一个Proof Checker。有了形式证明你就该放心多了吧。你总不能说这个很重要得放一开始去讲吧，你敢相信我这种渣渣写给你的Proof Checker没问题？有了形式证明，我们就可以讲一些实用的东西了。难道你想像那些水货一样，连Paxos都不会证明，只会躲在ZooKeeper，Etcd后面侃侃而谈分布式怎么怎么好？</p><p>既然是一本入门书，还可以顺便补一下必要的基础，讲讲数字电路，怎么写一个数字电路模拟器？也可以讲讲常用的数据结构。...... 等基础写得差不多了，就可以开始写偏实战的，比如怎么写个简化的CouchDB，Scalaris什么的。两个也可以同时开始写，反正重要的东西都写形式证明就是了，缺了就去补。这哪里一点都不偏理论好不好，你不能光看第一章就说这个不实用了。</p><p>其实也就这么一点点内容而已嘛。不过我想我一个人不可能写的完了。你们还不赶紧来写，不写来吐槽也行啊。</p><p>就是这样</p>",
            "image_url": "",
            "url": "",
            "excerpt_title": "",
            "excerpt": "前几天有几个人一致向我抱怨说这个21天学通Erlang是不是太偏理论了。我不认同这种观点。没人会否定Erlang是一门实用的语言。Erlang不需要一本Practical Common Lisp/Real World Haskell/Real World OCaml来标榜自己也是实用的。Erlang的成名不就是因为在上…"
        },
        {
            "type": "article",
            "updated": 1442728018,
            "id": 19921759,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1419596333,
            "title": "也谈作用域",
            "content": "<p>姚培森最近在Continuation专栏里的发了<a class=\"internal\" href=\"http://zhuanlan.zhihu.com/forallplt/19918834\">闭包</a>一文。我认为写的很烂，比“Monad不就是个自函子范畴上的幺半群”还烂。特别写一篇来喷。</p><p>假如一门语言允许你自己定义函数，那么就会出现作用域的问题。作用域的问题就是怎么找变量定义的问题。</p><p>假如不允许自定义函数，只需要一个变量名到变量值的映射就可以了。不妨把这种映射关系称为Environment。</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>%% 赋值前 {print: &lt;fun&gt;}\nvar a = 1\n%% 赋值后 {print: &lt;fun&gt;, a: 1}\nprint(a)\n</code></pre></div><p>现在来定义一个函数</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>var a = 1\nfun f(a)\n    print(a)\nend fun\nf(2)\nprint(a)\n</code></pre></div>此时我们期望的结果是<div class=\"highlight\"><pre><code class=\"language-text\"><span></span>2\n1\n</code></pre></div><p>要是在执行 f(2) 时，我们直接把a指向2，那么结果就是<br></p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>2\n2\n</code></pre></div><p>所以，函数f需要一个独立的Environment。在执行f(2)先把当前Environment保存下来（比如存在一个栈里，因为f函数里也可以去调用别的函数），建一个新的Environment，把a指向2，之后才开始执行f函数。</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>+------------------------------+\n| {a:2}                        |\n+------------------------------+\n| {print: &lt;fun&gt;, a:1, f:&lt;fun&gt;} |\n+------------------------------+\n</code></pre></div><p>不过这样就找不到print了。不过你一定想到了，只要沿着栈往下找总能找到的。</p><p>定义作用域规则，假如变量在当前Environment里，找不到就到外层Environment里找，直到找到为止，假如找到最外面也没有，那就是根本就没定义。</p><p>现在问题来了，看下面这个程序</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>var a = 1\n\nfun f()\n    print(a)\nend\n\nfun g(a)\n    f()\nend\n\ng(2)\n</code></pre></div><p>假如使用上述规则，那么结果就是</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>2\n</code></pre></div><p>原因很简单，因为当前栈是像下面这样的</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>+-----------------------------------------+\n| {}                                      |\n+-----------------------------------------+\n| {a:2}                                   |\n+-----------------------------------------+\n| {print: &lt;fun&gt;, a:1, f: &lt;fun&gt;, g: &lt;fun&gt;} |\n+-----------------------------------------+\n</code></pre></div><p>这意味着，在定义函数时，除了当前Environment里定义的，我们不知道其他变量到底是在哪里定义的。</p><p>我们把程序改一改 <br></p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>var a = 1\n\nfun f()\n    print(a)\nend\n\nfun g(print)\n    f()\nend\n\ng(2)\n</code></pre></div><p>现在栈是像下面这样的</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>+-----------------------------------------+\n| {}                                      |\n+-----------------------------------------+\n| {print:2}                               |\n+-----------------------------------------+\n| {print: &lt;fun&gt;, a:1, f: &lt;fun&gt;, g: &lt;fun&gt;} |\n+-----------------------------------------+\n</code></pre></div><p>运行到 print(a) 那行就出错了。那该咋办？我们可以把这叫做动态作用域，宣称这是最powerful的作用域，假如你不会用，那是因为你笨。这样问题就解决了。</p><p>可是我是弱智啊。我只能在定义时，就把所有会用到的变量都先存起来。找变量时，只在当前Environment里找。</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>+-------------------------------------------------+\n| {print: &lt;fun&gt;, a:1}                             |\n+-------------------------------------------------+\n| {print:2,                                       |\n|  f: {&lt;fun&gt;,{print: &lt;fun&gt;,a:1}}}                 |\n+-------------------------------------------------+\n| {print: &lt;fun&gt;, a:1,                             |\n|  f: {&lt;fun&gt;,{print:&lt;fun&gt;, a:1}},                 |\n|  g: {&lt;fun&gt;,{a:1, f: {&lt;fun&gt;,{print:&lt;fun&gt;,a:1}}}} |\n+-------------------------------------------------+\n</code></pre></div><p>这样就没问题了。这就是所谓的lexical scope<br></p><p>看下面这个程序 <br></p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>var a = 1\n\nfun f()\n    var a = a + 1\n    print(a)\nend\n\nf()\n</code></pre></div><p>在函数 f 里，a既是在外部定义的，又是在内部定义的。这样就有矛盾了。<br></p><p>有些语言的应对方式是在函数内部可以有多个Environment，规则类似动态作用域。</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>+---------------------------------+\n| +-----------------------------+ |\n| | {a: 2}                      | |\n| +-----------------------------+ |\n| | {print: &lt;fun&gt;, a:1}         | |\n| +-----------------------------+ |\n+---------------------------------+\n| {print: &lt;fun&gt;, a:1,             |\n|  f: {&lt;fun&gt;,{print:&lt;fun&gt;, a:1}}} |\n+---------------------------------+\n</code></pre></div><p>这样上面这段程序就能运行了。</p><p>有些语言不喜欢你这么定义，直接就不让你运行这样的程序。这似乎没啥问题。</p><p>有的语言的规则是local by default的，赋值就相当于定义了一个本地的变量。也就是</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>a = 1\n</code></pre></div><p> 相当于</p><div class=\"highlight\"><pre><code class=\"language-text\"><span></span>var a = 1\n</code></pre></div><p>这看上去也没什么问题。可是要是这语言变量的值是可以改的，那就糟了。内层函数就没法改外层函数变量的值了。这就需要引入 nonlocal 关键字了。</p><p>就是这样</p>",
            "image_url": "",
            "url": "",
            "excerpt_title": "",
            "excerpt": "姚培森最近在Continuation专栏里的发了<a class=\"internal\" href=\"http://zhuanlan.zhihu.com/forallplt/19918834\">闭包</a>一文。我认为写的很烂，比“Monad不就是个自函子范畴上的幺半群”还烂。特别写一篇来喷。假如一门语言允许你自己定义函数，那么就会出现作用域的问题。作用域的问题就是怎么找变量定义的问题。假如不允许自定义函…"
        },
        {
            "type": "article",
            "updated": 1459343320,
            "id": 19916813,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1418877644,
            "title": "Erlang能在OSv上启动了",
            "content": "<p>仅仅是能启动。</p><p>这是为了给还不存在的<b>Web IDE</b>找个合适的运行环境。虽然也可以基于AlpineLinux之类的微型Linux发行版来做，毕竟还是要写点脚本啥的，略麻烦。就去试试OSv了。</p><p>一开始按OSv Wiki上的说法，是要编译成.so才能运行的。我改了Makefile把beam改成beam.so，结果发现，Erlang在编译完beam之后，会用这个新编译出来的beam去编译erlang代码。那么问题就来了，改成.so之后根本就没法直接 exec 啊，make到这一步就失败了。</p><p>后来一想，这也不是什么问题，大不了既生成beam又生成beam.so就可以了嘛。没错，这样是能编译通过了。但是在OSv上怎么都运行不起来。在OSv的邮件列表里找，还没找到类似的问题，就看到说不用非得编译成.so的，只要编译成Position Independent Executable就可以了。那就把Makefile改回来。</p><p>我猜是默认开了很多选项，才导致启动不起来的。最后发现几乎都关完了还是开不起来。又去仔细看了看OSv Wiki，发现其实就是有个函数没实现嘛。那就照着样子弄个空的上去。结果还是启动不了，\"erts_poll_init(): Failed to get max number of files:\"。邮件列表里查了下，就是因为sysconf的实现是不完全的，随便返回个很大的整数就好了。打上<a href=\"https://link.zhihu.com/?target=https%3A//github.com/cloudius-systems/osv/commit/e42258914b9b65791b1c64bee0391a5c2b0790c7\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">补丁<i class=\"icon-external\"></i></a>，一个单线程的Erlang可以启动了。 <br></p><p>接着把SMP支持打开吧。却又启动不起来。结果发现有人在试图运行Go时，就已经碰到了类似的问题。用了他的<a class=\" wrap external\" href=\"https://link.zhihu.com/?target=https%3A//groups.google.com/d/msg/osv-dev/C6Qc2dyv_jc/qKjA0K1ATWoJ\" target=\"_blank\" rel=\"nofollow noreferrer\">补丁<i class=\"icon-external\"></i></a>，确实可以启动了。启动之后，我明显感觉到CPU风扇在加速。一看，top里qemu进程的CPU占用率是接近200%啊。在我还在找这是哪里的问题时，有人把之前那个补丁改好<a href=\"https://link.zhihu.com/?target=https%3A//github.com/cloudius-systems/osv/commit/50a431a731af759ed3a2e774fd19b5808676cf49\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">提交<i class=\"icon-external\"></i></a>进去了。他应该是没注意到开了SMP会出问题。</p><p>找来找去也没找到Erlang每个线程功能的文档。后来在<a class=\" wrap external\" href=\"https://link.zhihu.com/?target=http%3A//blog.etsukata.com/2014/02/erlang-vmbeam.html\" target=\"_blank\" rel=\"nofollow noreferrer\">Etsukata blog: Erlang VM(BEAM) スレッド構成<i class=\"icon-external\"></i></a>里才看到比较详细的说明。对照后发现就只有主线程和child waiter线程在占用CPU。看了下代码，就是OSv的<a class=\" wrap external\" href=\"https://link.zhihu.com/?target=https%3A//github.com/cloudius-systems/osv/commit/a2a4b3193d20fb0536f9ab2485b7b970a1be047c\" target=\"_blank\" rel=\"nofollow noreferrer\">select<i class=\"icon-external\"></i></a>和<a href=\"https://link.zhihu.com/?target=https%3A//github.com/cloudius-systems/osv/commit/45a703299c91c4bd839380a85daac34797855ad2\" class=\" wrap external\" target=\"_blank\" rel=\"nofollow noreferrer\">waitpid<i class=\"icon-external\"></i></a>有问题。改了就好了。</p><p>流水帐完了。<b>还不赶紧来写个Web IDE</b>。 </p><p>就是这样</p>",
            "image_url": "",
            "url": "",
            "excerpt_title": "",
            "excerpt": "仅仅是能启动。这是为了给还不存在的<b>Web IDE</b>找个合适的运行环境。虽然也可以基于AlpineLinux之类的微型Linux发行版来做，毕竟还是要写点脚本啥的，略麻烦。就去试试OSv了。一开始按OSv Wiki上的说法，是要编译成.so才能运行的。我改了Makefile把beam改成bea…"
        },
        {
            "type": "article",
            "updated": 1459343296,
            "id": 19914764,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1418629682,
            "title": "21天学通Erlang需要你",
            "content": "<p>我的观点是， 21天学通Erlang是完全针对初学者的，最终能让6岁的小朋友都能借此自学Erlang。这不意味着，就不适合别的年龄段了，我只是希望只要能熟练笔算两位整数加减乘除的都不会碰到任何看不明白的地方。</p><p>我不打算也无力让21天学通Erlang达到能出版的水准。我也不认为出版是个好主意。书印好了就没法改了，而且，就算写的再好，也难逃最终绝版的命，这样很不好。我希望能像开源软件一样，大家一起来修正一起来更新，想要看的人只要有网络随时就能下载到。</p><p>目前已完成初步的排版，虽然是丑了点，但是功能上的要求基本都达到了。运行 make screen.pdf 之后，再运行 escript check.erl 就会检查所有引用的源代码确实能和文件名以及行号对应起来，所有列出的Erlang Shell的输出结果确实和PDF中列出的一样。每个tex文件都可以单独生成PDF。生成供在线阅读的SVG时，每个小节单独占一页。目前所采用的生成SVG的方式还不太合理，正在写一个脚本，能生成更好的SVG，至少文字用一下Web Font而不是直接画成SVG。<br></p><p>同时，现在也在寻找对初学者来说更方便的安装方式。我的想法是，提供一个虚拟机镜像，直接在虚拟机里运行，提供一个Web IDE，这样就不用担心会在安装软件时碰到问题了，特别是环境变量相关的配置。现在正在尝试在OSv上运行Erlang，至于Web IDE怎么写，还没什么思路。<br></p><p>语言选Erlang是因为Erlang这门语言非常简单，概念很少，特别适合入门。要是选了Scheme这种复杂的语言，就算是很多人推崇的SICP也得先用三章，才能开始讲怎么用程序去解释一个简化的Scheme。对于一本针对初学者的书，这显然是不合适的。</p><p>21天学通Erlang才刚刚开始，需要你的各种帮助。你可以直接来写书的内容，吐槽目前已经有的内容，只要你觉得有任何不合适或者看不明白的地方，都是值得吐槽的。改进排版，写一个PDF转SVG的脚本，写一个用来编辑Erlang的Web IDE，任何你觉得不够好的地方，都可以参与进来改进。也可以帮助忽悠别人来参与，比如忽悠知乎上的温赵轮之类的大神们来一起写。总之，21天学通Erlang需要你。</p><p> 地址： </p><p><a class=\" wrap external\" href=\"https://link.zhihu.com/?target=http%3A//is.gd/erlang21p\" target=\"_blank\" rel=\"nofollow noreferrer\">21天学通erlang.github.io<i class=\"icon-external\"></i></a></p><br><p>讨论/吐槽：</p><p><a class=\" wrap external\" href=\"https://link.zhihu.com/?target=http%3A//is.gd/erlang21b\" target=\"_blank\" rel=\"nofollow noreferrer\">https://gitcafe.com/erlang/e21/tickets<i class=\"icon-external\"></i></a><br></p><p>就是这样</p>",
            "image_url": "",
            "url": "",
            "excerpt_title": "",
            "excerpt": "我的观点是， 21天学通Erlang是完全针对初学者的，最终能让6岁的小朋友都能借此自学Erlang。这不意味着，就不适合别的年龄段了，我只是希望只要能熟练笔算两位整数加减乘除的都不会碰到任何看不明白的地方。我不打算也无力让21天学通Erlang达到能出版的水准…"
        },
        {
            "type": "article",
            "updated": 1418097119,
            "id": 19911152,
            "author": {
                "headline": "正在找工作 ...",
                "avatar_url_template": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_{size}.jpg",
                "is_advertiser": false,
                "type": "people",
                "id": "dcddea61834f6b2dcb515f393fe29575",
                "url_token": "bhuztez",
                "user_type": "people",
                "name": "bhuztez",
                "is_org": false,
                "gender": 1,
                "badge": [],
                "url": "https://www.zhihu.com/api/v4/people/dcddea61834f6b2dcb515f393fe29575",
                "avatar_url": "https://pic3.zhimg.com/e59aeb8898c50a830976297787cdce86_is.jpg"
            },
            "comment_permission": "all",
            "created": 1418095454,
            "title": "开通专栏了",
            "content": "<p>感谢大家支持</p><p>以下是<a class=\" wrap external\" href=\"https://link.zhihu.com/?target=http%3A//www.youtube.com/watch%3Fv%3DrRbY3TMUcgQ\" target=\"_blank\" rel=\"nofollow noreferrer\">Erlang The Movie II: The Sequel<i class=\"icon-external\"></i></a>的transcript。也就是专栏简介的出处。<br></p><blockquote><p><strong>Joe:</strong> Declarative programming languages have several advantages over\ntraditional languages. For example, programs in such languages are\nconsiderably shorter than equivalent programs in imperative languages. Here for\nexample, is a program in C… and here is the equivalent program in Erlang.</p><p>[phone rings]</p><p><strong>Joe:</strong> Hello.</p><p><strong>Mike:</strong> Hello Joe.</p><p><strong>Joe:</strong> Hello Mike.</p><p><strong>Mike:</strong> Question… does anyone care about the differences between\ndeclarative and imperative languages anymore?</p><p><strong>Joe:</strong> Don’t be silly. The declarative/imperative debate is always a crowd\npleaser!</p><p><strong>Mike:</strong> From what I can tell, kids these days are going with what’s cool,\nlike Node.js and Ruby on Rails. Let’s ask Robert.</p><p>[phone rings]</p><p><strong>Mike:</strong> Hello, Robert?</p><p><strong>Robert:</strong> Hello Mike.</p><p><strong>Mike:</strong> Joe’s back to talking about declarative languages again. I just think\nErlang’s got a problem when its spokesman is an old fuddy-duddy. Eh Joe?</p><p><strong>Joe:</strong> Bite me.</p><p><strong>Mike:</strong> Robert, what do you think?</p><p><strong>Robert:</strong> Erlang’s the shizzah! But I can’t blame kids for picking something a\nlittle less… crusty.</p><p><strong>Mike:</strong> Erlang’s image is stuck in the 1980s. It’s the Bananarama of languages.</p><p><strong>Joe:</strong> Okay. Tell you what. This is bullshit. If kids these days don’t want\nto use Erlang, which is the real “rock star tech” then fuck it. I’ll turn this\nvideo off and go home. Take my nine nines with me!</p><p>[video turns off]</p><p><strong>Mike:</strong> Joe, I didn’t mean anything by it.</p><p><strong>Robert:</strong> Yeah Joe, Mike was just trying to be constructive.</p><p><strong>Mike:</strong> Joe, turn the video back on.</p><p><strong>Joe:</strong> I won’t. I won’t have Erlang disparaged!</p><p>[stranger’s voice]</p><p><strong>Rex:</strong> Yo yo yo. I can totally help you geezers.</p><p><strong>Joe:</strong> Who said that?</p><p><strong>Rex:</strong> All Erlang needs is an image upgrade.</p><p>[video turns on]</p><p><strong>Joe:</strong> That’s very interesting.</p><p><strong>Rex:</strong> Lots of things from the eighties are cool. Just look at Fraggle Rock\nand Super Mario Brothers.</p><p><strong>Mike:</strong> What the hell is that?</p><p><strong>Robert:</strong> It’s one of those Ruby hipsters!</p><p><strong>Rex:</strong> Watch it grandpa. Just because I carry my Mac in a messager bag and\nhave great taste in nose rings doesn’t mean I use Ruby!</p><p><strong>Joe:</strong> I for one and interested in what the little girl has to say.</p><p><strong>Rex:</strong> Yo, whatever. First we have to fix the name. A language named after a\nnineteenth century Danish mathematician is about as cool as having a Facebook\naccount.</p><p><strong>Robert:</strong> It’s just like the olden days, when Erlang was banned. We had to change\nthe name.</p><p><strong>Mike:</strong> That’s right. When Erlang fell out of fashion at Ericsson, we changed the name to OTP.</p><p><strong>Joe:</strong> Three of the trendiest names we could think of: “open”, “telecom”,\n“platform”.</p><p><strong>Robert:</strong> Gives me the chills just thinking about it.</p><p><strong>Rex:</strong> Okay, that’s bullcrap. No one care about telecom platforms. We need\nsomething fresh. Something edgy.</p><p><strong>Robert:</strong> Like “Erlang on Rails”!</p><p><strong>Rex:</strong> Jesus Christ. The last thing you want to do is imitate. No. Something\noriginal.</p><p><strong>Joe:</strong> How about “Erlang++”?</p><p><strong>Rex:</strong> I got it! We keep OTP, but with a hip, edgy twist. Check it. Your\nlanguage will hereby be known as “Outlaw Techno Psychobitch”!</p><p>[Joe scowls]</p><p><strong>Robert:</strong> It does spell “OTP”.</p><p><strong>Mike:</strong> Don’t know what it has to do with software. What do you think Joe?</p><p>[Joe pause]</p><p><strong>Joe:</strong> I absolutely love it! That name is fucking gangster!</p><p><strong>Rex:</strong> Yeah Joe. You rule! Okay, next thing we need is a video that is just\nas cool as the original Erlang The Movie, but speaks to today’s programmer\nhipster. I’m thinking something like this…</p><p>[video starts]</p><p>“Outlaw Techno Psychobitch” - “OTP” - “Programming for Bad Ass Mother Fers!”</p><p><strong>Rex:</strong> Yo, what up bitches. Rex here. This time I’m talking about a bad ass new\nlanguage called “Outlaw Techno Psychobitch”, or “OTP” for short.</p><p>So, you all know I’m a huge Ruby fan. Ruby gives you 15 ways to do the same\nthing and freedom of choice is good. Then I realized, that’s just 15 different\nways to create really slow, crappy programs.</p><p>Then I started using Node.js. I like Node because, as my hero Ryan Dahl says,\n“it’s like coloring with crayons and playing with Duplo blocks.” But as it\nturns out, it’s less like playing with Duplo blocks and more like playing with\nslinkies. Slinkies that get tangled together and impossible to separate.</p><p>So then I checked out Outlaw Techno Psychobitch. It’s a language out of Sweden\nthat can be used to build web scale, asynchronous, non-blocking, sharded, event\ndriven, message passing, NoSQL, reliable, highly available, high performance,\nreal time, clusterable, bad ass, rock star, get the girls, get the boys,\nimpress your mom, impress your cat applications!</p><p>Ryan Dahl, my hero, says “we should not be supporting more programming\nlanguages,” that we should be “killing them”. That “all these bullshit projects\nare confusing people.” But Psychobitch is just so damn cool, I couldn’t resist\ngiving it a try.</p><p>The first thing Psychobitch kills off is curly braces. Thank God. After a half\ncentury of curly braces, we need something that’s fresh. Psychobitch uses\nsingle character block delimiters, like in sentences.</p><p>My hero Ryan Dahl says, “math is not necessary,” that “people who think it’s\nsuperior to curly braces are wrong.” But I figure, if math can get a rover to\nMars, maybe it can help us write better programs.</p><p>Psychobitch gets pretty uptight about logic. If you say X is one, then turn\naround and say X is two, Psychobitch goes ape shit. She’s like, “what the hell,\nwhen did one start equalling two?”</p><p>Psychobitch has this great feature called “pattern matching”. You define the\npatterns and if there’s a match your program keeps going. If something doesn’t\nmatch it crashes. Like assertions but built in.</p><p>What happens when your program crashes? Psychobitch has you covered. It\nmonitors your code and restart things that break. It’s like the Terminator. You\ncan blast it in the face with a shot gun — it stops for a second, then keeps\non coming!</p><p>I’ve written a chat server in Psychobitch. It’s where all my friends and me can\nchat about how awesome Ryan Dahl is. Because the server is written in\nPsychobitch, it can easily handle thousands of concurrent users. Shit, did I\nsay thousands? Because I meant tens of thousands. And by tens of thousands, I\nmean hundreds of thousands.</p><p>[switch to demo]</p><p>I’m already logged in as myself at the top. I’ll log in as another user. You\nsay something using the “tell” command. The messages are received instantly\neven though there are hundreds of thousands of connected users. I’ll use the\n“yell” command to broadcast a message to every user.</p><p>[uses yell command]</p><p>That literally sent the message to 300,000 users. About a second.</p><p>Okay, 300,000 concurrent users is impressive. But even Node.js can do\nthat. Let’s try something hard. To make things interesting, we’ll trigger a bug\non the server.</p><p>[types a message and triggers a bug]</p><p>Damn. I must have said something bad. But as you can see, Mary and Jack can\nstill chat. Of the 300,000 users on the server, I’m the only one affected.</p><p>Let’s see if we can fix the bug. Here’s the code. Holy crap! It looks like the\noriginal programmer, in his zeal, added some forbidden utterances. Let’s clean\nthis up because we don’t want to censor.</p><p>[fixed bug in code]</p><p>Okay, I recompiled the code. Next, I’ll reload it in real time with 300,000\nconcurrent chats going on.</p><p>[reloads code]</p><p>Done. In case you missed it, here it is again — in slow motion.</p><p>[reloads code, in slow motion]</p><p>For some of you, what you just saw is not self explanatory. If gracefully\nhandling bugs with hundreds of thousands of concurrent sessions and fixing them\nin real time without stopping the server seems passe, you can aways use\nRuby. Then, when your app doesn’t scale, move to Node.js. Then, when you can’t\nmaintain your code because it’s a pile of tangled slinkies, move to\nPsychobitch. With that experience you can appreciate what you just saw. For\nthe rest of you, yes, that just happened.</p><p>[video stops]</p><p><strong>Rex:</strong> So, what do you guys think about Psychobitch?</p><p><strong>Robert:</strong> She’s utterly terrifying.</p><p><strong>Joe:</strong> It makes me wonder if perhaps Psychobitch is a real person.</p><p><strong>Rex:</strong> You mean, is the name based on my experience with a girlfriend who’s\nbat shit crazy, drop dead gorgeous, brilliant, and brags to her friends about\ncosting me tens of thousands of dollars in therapy over the last three years?</p><p><strong>Mike:</strong> Oh shit. I know a girl like that. She scarred me for life,\nliterally. Seriously, I’ll show you the scars!</p></blockquote>",
            "image_url": "",
            "url": "",
            "excerpt_title": "",
            "excerpt": "感谢大家支持以下是<a class=\"\" data-title=\"youtube.com 的页面\" data-editable=\"true\" href=\"http://www.youtube.com/watch?v=rRbY3TMUcgQ\">Erlang The Movie II: The Sequel</a>的transcript。也就是专栏简介的出处。 <strong>Joe:</strong> Declarative programming languages have several advantages over\ntraditional languages. For example, programs in such languages are\nconsiderably shor…"
        }
    ]
}